
// Source "Studio" models, which seem to be named because of their original ties to 3D Studio Max
// https://developer.valvesoftware.com/wiki/Studiomodel

import ArrayBufferSlice from "../ArrayBufferSlice";
import { GfxDevice, GfxBuffer, GfxInputLayout, GfxInputState, GfxBufferUsage, GfxVertexAttributeDescriptor, GfxFormat, GfxInputLayoutBufferDescriptor, GfxVertexBufferFrequency, GfxVertexBufferDescriptor } from "../gfx/platform/GfxPlatform";
import { assert, readString, nArray, assertExists } from "../util";
import { SourceFileSystem, SourceRenderContext } from "./Main";
import { AABB } from "../Geometry";
import { GfxRenderCache } from "../gfx/render/GfxRenderCache";
import { makeStaticDataBuffer } from "../gfx/helpers/BufferHelpers";
import { MaterialProgramBase, BaseMaterial, EntityMaterialParameters, StaticLightingMode } from "./Materials";
import { GfxRenderInstManager } from "../gfx/render/GfxRenderer";
import { mat4 } from "gl-matrix";

// Encompasses the MDL, VVD & VTX formats.

const enum StudioModelFlags {
    AUTOGENERATED_HITBOX           = 0x0001,
    FORCE_OPAQUE                   = 0x0004,
    STATIC_PROP                    = 0x0010,
    CONSTANT_DIRECTIONAL_LIGHT_DOT = 0x2000,
}

const enum OptimizeStripGroupFlags {
    IS_FLEXED                      = 0x01,
    IS_HWSKINNED                   = 0x02,
    IS_DELTA_FLEXED                = 0x04,
}

const enum OptimizeStripFlags {
    IS_TRILIST                     = 0x01,
    IS_TRISTRIP                    = 0x02,
}

class StudioModelStripData {
    constructor(public firstIndex: number, public indexCount: number) {
    }
}

// TODO(jstpierre): Coalesce all buffers for a studio model?
class StudioModelStripGroupData {
    public stripData: StudioModelStripData[] = [];

    constructor() {
    }
}

class StudioModelMeshData {
    public vertexBuffer: GfxBuffer;
    public indexBuffer: GfxBuffer;
    public inputLayoutWithoutColorMesh: GfxInputLayout;
    public inputStateWithoutColorMesh: GfxInputState;
    public inputLayoutWithColorMesh: GfxInputLayout;

    public stripGroupData: StudioModelStripGroupData[] = [];

    constructor(device: GfxDevice, cache: GfxRenderCache, public materialName: string, vertexData: ArrayBuffer, indexData: ArrayBuffer) {
        this.vertexBuffer = makeStaticDataBuffer(device, GfxBufferUsage.VERTEX, vertexData);
        this.indexBuffer = makeStaticDataBuffer(device, GfxBufferUsage.INDEX, indexData);

        const vertexAttributeDescriptors: GfxVertexAttributeDescriptor[] = [
            { location: MaterialProgramBase.a_Position, bufferIndex: 0, bufferByteOffset: 0*0x04, format: GfxFormat.F32_RGB, },
            { location: MaterialProgramBase.a_Normal,   bufferIndex: 0, bufferByteOffset: 3*0x04, format: GfxFormat.F32_RGBA, },
            { location: MaterialProgramBase.a_TangentS, bufferIndex: 0, bufferByteOffset: 7*0x04, format: GfxFormat.F32_RGBA, },
            { location: MaterialProgramBase.a_TexCoord, bufferIndex: 0, bufferByteOffset: 11*0x04, format: GfxFormat.F32_RG, },
        ];
        const vertexBufferDescriptors: GfxInputLayoutBufferDescriptor[] = [
            { byteStride: (3+4+4+2)*0x04, frequency: GfxVertexBufferFrequency.PER_VERTEX, },
        ];
        const indexBufferFormat = GfxFormat.U16_R;
        this.inputLayoutWithoutColorMesh = cache.createInputLayout(device, { vertexAttributeDescriptors, vertexBufferDescriptors, indexBufferFormat });

        // Tack on the color mesh.
        vertexAttributeDescriptors.push(
            { location: MaterialProgramBase.a_StaticVertexLighting, bufferIndex: 1, bufferByteOffset: 0*0x04, format: GfxFormat.U8_RGBA_NORM, },
        );
        vertexBufferDescriptors.push(
            { byteStride: 0x04,           frequency: GfxVertexBufferFrequency.PER_VERTEX, },
        );
        this.inputLayoutWithColorMesh = cache.createInputLayout(device, { vertexAttributeDescriptors, vertexBufferDescriptors, indexBufferFormat });

        // Create our base input state.
        this.inputStateWithoutColorMesh = device.createInputState(this.inputLayoutWithoutColorMesh, [
            { buffer: this.vertexBuffer, byteOffset: 0, },
        ], { buffer: this.indexBuffer, byteOffset: 0, });
    }

    public createInputStateWithColorMesh(device: GfxDevice, meshBufferDescriptor: GfxVertexBufferDescriptor): GfxInputState {
        return device.createInputState(this.inputLayoutWithColorMesh, [
            { buffer: this.vertexBuffer, byteOffset: 0, },
            meshBufferDescriptor,
        ], { buffer: this.indexBuffer, byteOffset: 0, });
    }

    public destroy(device: GfxDevice): void {
        device.destroyBuffer(this.vertexBuffer);
        device.destroyBuffer(this.indexBuffer);
        device.destroyInputState(this.inputStateWithoutColorMesh);
    }
}

class StudioModelLODData {
    public meshData: StudioModelMeshData[] = [];

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.meshData.length; i++)
            this.meshData[i].destroy(device);
    }
}

class StudioModelSubmodelData {
    public lodData: StudioModelLODData[] = [];

    constructor(public name: string) {
    }

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.lodData.length; i++)
            this.lodData[i].destroy(device);
    }
}

class StudioModelBodyPartData {
    public submodelData: StudioModelSubmodelData[] = [];

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.submodelData.length; i++)
            this.submodelData[i].destroy(device);
    }
}

interface FixupRemapping { copySrc: number; copyDst: number; count: number; }
function fixupRemappingSearch(fixupTable: FixupRemapping[], dstIdx: number): number {
    for (let i = 0; i < fixupTable.length; i++) {
        const map = fixupTable[i];
        const idx = dstIdx - map.copyDst;
        if (idx >= 0 && idx < map.count)
            return map.copySrc + idx;
    }

    // remap did not copy over this vertex, return as is.
    return dstIdx;
}

/*
class ResizableArrayBuffer {
    private buffer: ArrayBuffer;
    private byteSize: number;
    private byteCapacity: number;

    constructor(initialSize: number = 0x400) {
        this.byteSize = 0;
        this.byteCapacity = initialSize;
        this.buffer = new ArrayBuffer(initialSize);
    }

    public ensureSize(byteSize: number): void {
        this.byteSize = byteSize;

        if (byteSize > this.byteCapacity) {
            this.byteCapacity = Math.max(byteSize, this.byteCapacity * 2);
            const oldBuffer = this.buffer;
            const newBuffer = new ArrayBuffer(this.byteCapacity);
            new Uint8Array(newBuffer).set(new Uint8Array(oldBuffer));
            this.buffer = newBuffer;
        }
    }

    public addByteSize(byteSize: number): void {
        this.ensureSize(this.byteSize + byteSize);
    }

    public addUint16(count: number): [number, Uint16Array] {
        const offs = this.byteSize;
        this.addByteSize(count << 1);
        return [offs >>> 1, new Uint16Array(this.buffer, offs, count)];
    }

    public addFloat32(count: number): [number, Float32Array] {
        const offs = this.byteSize;
        this.addByteSize(count << 2);
        return [offs >>> 2, new Float32Array(this.buffer, offs, count)];
    }

    public finalize(): ArrayBuffer {
        return ArrayBuffer_slice.call(this.buffer, 0, this.byteSize);
    }
}
*/

export class StudioModelData {
    public bodyPartData: StudioModelBodyPartData[] = [];
    public checksum: number;
    public bbox: AABB;

    constructor(renderContext: SourceRenderContext, mdlBuffer: ArrayBufferSlice, vvdBuffer: ArrayBufferSlice, vtxBuffer: ArrayBufferSlice) {
        const mdlView = mdlBuffer.createDataView();

        // Parse MDL header
        assert(readString(mdlBuffer, 0x00, 0x04) === 'IDST');
        const mdlVersion = mdlView.getUint32(0x04, true);

        const supportedVersions = [44, 45, 46, 47, 48];
        assert(supportedVersions.includes(mdlVersion));

        this.checksum = mdlView.getUint32(0x08, true);

        const name = readString(mdlBuffer, 0x0C, 0x40, true);
        const length = mdlView.getUint32(0x4C, true);

        const eyePositionX = mdlView.getFloat32(0x50, true);
        const eyePositionY = mdlView.getFloat32(0x54, true);
        const eyePositionZ = mdlView.getFloat32(0x58, true);

        const illumPositionX = mdlView.getFloat32(0x5C, true);
        const illumPositionY = mdlView.getFloat32(0x60, true);
        const illumPositionZ = mdlView.getFloat32(0x64, true);

        const moveHullMinX = mdlView.getFloat32(0x68, true);
        const moveHullMinY = mdlView.getFloat32(0x6C, true);
        const moveHullMinZ = mdlView.getFloat32(0x70, true);
        const moveHullMaxX = mdlView.getFloat32(0x74, true);
        const moveHullMaxY = mdlView.getFloat32(0x78, true);
        const moveHullMaxZ = mdlView.getFloat32(0x7C, true);

        const bboxMinX = mdlView.getFloat32(0x80, true);
        const bboxMinY = mdlView.getFloat32(0x84, true);
        const bboxMinZ = mdlView.getFloat32(0x88, true);
        const bboxMaxX = mdlView.getFloat32(0x8C, true);
        const bboxMaxY = mdlView.getFloat32(0x90, true);
        const bboxMaxZ = mdlView.getFloat32(0x94, true);
        this.bbox = new AABB(bboxMinX, bboxMinY, bboxMinZ, bboxMaxX, bboxMaxY, bboxMaxZ);

        const flags: StudioModelFlags = mdlView.getUint32(0x98, true);
        const isStaticProp = !!(flags & StudioModelFlags.STATIC_PROP);
        // We only support static props right now.
        assert(isStaticProp);

        const numbones = mdlView.getUint32(0x9C, true);
        const boneindex = mdlView.getUint32(0xA0, true);

        const numbonecontrollers = mdlView.getUint32(0xA4, true);
        const bonecontrollerindex = mdlView.getUint32(0xA8, true);
        if (isStaticProp)
            assert(numbonecontrollers === 0);

        const numhitboxsets = mdlView.getUint32(0xAC, true);
        const hitboxsetindex = mdlView.getUint32(0xB0, true);

        const numlocalanims = mdlView.getUint32(0xB4, true);
        const localanimindex = mdlView.getUint32(0xB8, true);

        const numlocalseqs = mdlView.getUint32(0xBC, true);
        const localseqindex = mdlView.getUint32(0xC0, true);
        const activitylistversion = mdlView.getUint32(0xC4, true);
        const eventsindexed = mdlView.getUint32(0xC8, true);

        const numtextures = mdlView.getUint32(0xCC, true);
        const textureindex = mdlView.getUint32(0xD0, true);

        const numcdtextures = mdlView.getUint32(0xD4, true);
        const cdtextureindex = mdlView.getUint32(0xD8, true);

        const materialSearchDirs: string[] = [];
        let cdtextureIdx = cdtextureindex;
        for (let i = 0; i < numcdtextures; i++) {
            const textureDir = readString(mdlBuffer, mdlView.getUint32(cdtextureIdx + 0x00, true));
            const materialSearchDir = `materials/${textureDir}`;
            materialSearchDirs.push(materialSearchDir);
            cdtextureIdx += 0x04;
        }

        const numskinref = mdlView.getUint32(0xDC, true);
        const numskinfamilies = mdlView.getUint32(0xE0, true);
        const skinindex = mdlView.getUint32(0xE4, true);

        const numbodyparts = mdlView.getUint32(0xE8, true);
        const bodypartindex = mdlView.getUint32(0xEC, true);

        const numlocalattachments = mdlView.getUint32(0xF0, true);
        const localattachmentindex = mdlView.getUint32(0xF4, true);

        const numlocalnodes = mdlView.getUint32(0xF8, true);
        const localnodeindex = mdlView.getUint32(0xFC, true);
        const localnodenameindex = mdlView.getUint32(0x100, true);

        const numflexdesc = mdlView.getUint32(0x104, true);
        const flexdescindex = mdlView.getUint32(0x108, true);

        const numflexcontrollers = mdlView.getUint32(0x10C, true);
        const flexcontrollerindex = mdlView.getUint32(0x110, true);

        const numflexrules = mdlView.getUint32(0x114, true);
        const flexruleindex = mdlView.getUint32(0x118, true);

        const numikchains = mdlView.getUint32(0x11C, true);
        const ikchainindex = mdlView.getUint32(0x120, true);

        const nummouthss = mdlView.getUint32(0x124, true);
        const mouthsindex = mdlView.getUint32(0x128, true);

        const numlocalposeparameters = mdlView.getUint32(0x12C, true);
        const localposeparamindex = mdlView.getUint32(0x130, true);

        const surfacepropindex = mdlView.getUint32(0x134, true);
        const surfaceprop = readString(mdlBuffer, surfacepropindex);

        const keyvalueindex = mdlView.getUint32(0x138, true);
        const keyvaluesize = mdlView.getUint32(0x13C, true);

        const numlocalikautoplaylocks = mdlView.getUint32(0x140, true);
        const localikautoplaylockindex = mdlView.getUint32(0x144, true);

        const mass = mdlView.getFloat32(0x148, true);
        const contents = mdlView.getUint32(0x14C, true);

        const numincludemodels = mdlView.getUint32(0x150, true);
        const includemodelindex = mdlView.getUint32(0x154, true);

        // Runtime backpointer.
        const virtualModel = mdlView.getUint32(0x158, true);
        assert(virtualModel === 0);

        const animblocknameindex = mdlView.getUint32(0x15C, true);
        const numanimblocks = mdlView.getUint32(0x160, true);
        const animblockindex = mdlView.getUint32(0x164, true);
        const animblockModel = mdlView.getUint32(0x168, true);

        const bonetablebynameindex = mdlView.getUint32(0x16C, true);

        // Runtime backpointer.
        const vertexBase = mdlView.getUint32(0x170, true);
        const indexBase = mdlView.getUint32(0x174, true);
        assert(vertexBase === 0);
        assert(indexBase === 0);

        const constantdirectionallightdot = mdlView.getUint32(0x178, true);
        const rootLOD = mdlView.getUint32(0x179, true);
        const numAllowedRootLODs = mdlView.getUint32(0x17A, true);

        const numflexcontrollerui = mdlView.getUint32(0x180, true);
        const flexcontrollleruiindex = mdlView.getUint32(0x184, true);

        const vertAnimFixedPointScale = mdlView.getFloat32(0x188, true);
        const studiohdr2index = mdlView.getUint32(0x190, true);

        // Parse VVD header
        const vvdView = vvdBuffer.createDataView();

        assert(readString(vvdBuffer, 0x00, 0x04) === 'IDSV');
        const vvdVersion = vvdView.getUint32(0x04, true);
        assert(vvdVersion === 0x04);
        const vvdChecksum = vvdView.getUint32(0x08, true);
        assert(vvdChecksum === this.checksum);
        const vvdNumLODs = vvdView.getUint32(0x0C, true);
        const vvdNumLODVertexes = nArray(8, (i) => vvdView.getUint32(0x10 + i * 0x04, true));
        const vvdNumFixups = vvdView.getUint32(0x30, true);
        const vvdFixupTableStart = vvdView.getUint32(0x34, true);
        const vvdVertexDataStart = vvdView.getUint32(0x38, true);
        const vvdTangentDataStart = vvdView.getUint32(0x3C, true);

        const fixupRemappings: FixupRemapping[] = [];
        let vvdFixupTableIdx = vvdFixupTableStart;
        let fixupTableCopyDstIdx = 0;
        for (let i = 0; i < vvdNumFixups; i++) {
            const lod = vvdView.getUint32(vvdFixupTableIdx + 0x00, true);
            // The fixup table works by memcpy-ing vertex data from src -> dst. So the indices in the
            // MDL/VTX files are in copyDst range, and the vertices in the VVD file are in copySrc.
            const copySrc = vvdView.getUint32(vvdFixupTableIdx + 0x04, true);
            const copyDst = fixupTableCopyDstIdx;
            const count = vvdView.getUint32(vvdFixupTableIdx + 0x08, true);
            fixupRemappings.push({ copySrc, copyDst, count });
            fixupTableCopyDstIdx += count;
            vvdFixupTableIdx += 0x0C;
        }

        // Parse VTX header
        const vtxView = vtxBuffer.createDataView();

        const vtxVersion = vtxView.getUint32(0x00, true);
        assert(vtxVersion === 0x07);

        // VTX optimization settings.
        const vtxCacheSize = vtxView.getUint32(0x04, true);
        const vtxMaxBonesPerStrip = vtxView.getUint16(0x08, true);
        const vtxMaxBonesPerTri = vtxView.getUint16(0x0A, true);
        const vtxMaxBonesPerVert = vtxView.getUint32(0x0C, true);

        const vtxChecksum = vtxView.getUint32(0x10, true);
        assert(vtxChecksum === this.checksum);

        const vtxNumLODs = vtxView.getUint32(0x14, true);
        assert(vtxNumLODs === vvdNumLODs);
        const vtxMaterialReplacementListOffset = vtxView.getUint32(0x18, true);
        const vtxNumBodyParts = vtxView.getUint32(0x1C, true);
        assert(vtxNumBodyParts === numbodyparts);
        const vtxBodyPartOffset = vtxView.getUint32(0x20, true);

        // Gather our materials for each LOD.
        // First, gather our base material names.
        const baseMaterialNames: string[] = [];
        let textureIdx = textureindex;
        for (let i = 0; i < numtextures; i++) {
            const nameindex = textureIdx + mdlView.getUint32(textureIdx + 0x00, true);
            const materialName = readString(mdlBuffer, nameindex);
            const flags = mdlView.getUint32(textureIdx + 0x04, true);
            const used = mdlView.getUint32(textureIdx + 0x08, true);
            const unused1 = mdlView.getUint32(textureIdx + 0x0C, true);
            const material = mdlView.getUint32(textureIdx + 0x10, true);
            // This appears to be a stale pointer generated by studiomdl, lol.
            // assert(material === 0);
            const clientmaterial = mdlView.getUint32(textureIdx + 0x14, true);
            assert(clientmaterial === 0);

            const resolvedPath = renderContext.filesystem.searchPath(materialSearchDirs, materialName, '.vmt');
            if (resolvedPath !== null) {
                baseMaterialNames.push(resolvedPath);
            } else {
                // TODO(jstpierre): Error material
                baseMaterialNames.push('materials/editor/obsolete.vmt');
            }

            textureIdx += 0x40;
        }

        const lodMaterialNames: string[][] = [];
        let vtxMaterialReplacementListIdx = vtxMaterialReplacementListOffset;
        for (let i = 0; i < vtxNumLODs; i++) {
            const numReplacements = vtxView.getUint32(vtxMaterialReplacementListIdx + 0x00, true);
            const replacementOffset = vtxView.getUint32(vtxMaterialReplacementListIdx + 0x04, true);

            const materialNames: string[] = baseMaterialNames.slice();
            let replacementIdx = vtxMaterialReplacementListIdx + replacementOffset;
            for (let i = 0; i < numReplacements; i++) {
                const materialID = vtxView.getUint16(replacementIdx + 0x00, true);
                assert(materialID < materialNames.length);
                const nameOffset = replacementIdx + vtxView.getUint32(replacementIdx + 0x04, true);
                const replacementName = readString(vtxBuffer, nameOffset);
                materialNames[materialID] = assertExists(renderContext.filesystem.searchPath(materialSearchDirs, replacementName, '.vmt'));
            }

            lodMaterialNames.push(materialNames);
            vtxMaterialReplacementListIdx += 0x08;
        }

        // We have three separate files of data (MDL, VVD, VTX) to chew through.
        //
        // MDL = Studio Model Header, contains skeleton, most aux data, animations, etc.
        // VVD = Valve Vertex Data, contains actual vertex data.
        // VTX = Optimized Model, contains per-LOD information (index buffer, optimized trilist information & material replacement).

        // The hierarchy of a model is Body Part -> Submodel -> Submodel LOD -> Mesh -> Mesh Group -> Strip
        // Note that "strips" might not actually be tristrips. They appear to be trilists in modern models.

        let mdlBodyPartIdx = bodypartindex;
        let vtxBodyPartIdx = vtxBodyPartOffset;
        for (let i = 0; i < numbodyparts; i++) {
            const bodyPartName = readString(mdlBuffer, mdlBodyPartIdx + mdlView.getUint32(mdlBodyPartIdx + 0x00, true));
            const mdlNumModels = mdlView.getUint32(mdlBodyPartIdx + 0x04, true);
            const mdlBase = mdlView.getUint32(mdlBodyPartIdx + 0x08, true);
            const mdlModelindex = mdlView.getUint32(mdlBodyPartIdx + 0x0C, true);

            const vtxNumModels = vtxView.getUint32(vtxBodyPartIdx + 0x00, true);
            assert(mdlNumModels === vtxNumModels);
            const vtxModelOffs = vtxView.getUint32(vtxBodyPartOffset + 0x04, true);

            const bodyPartData = new StudioModelBodyPartData();
            this.bodyPartData.push(bodyPartData);

            let mdlSubmodelIdx = mdlBodyPartIdx + mdlModelindex;
            let vtxSubmodelIdx = vtxBodyPartIdx + vtxModelOffs;
            for (let j = 0; j < mdlNumModels; j++) {
                const mdlSubmodelName = readString(mdlBuffer, mdlSubmodelIdx + 0x00);
                // Never written to.
                // const mdlSubmodelType = mdlView.getUint32(mdlSubmodelIdx + 0x40, true);
                const mdlSubmodelBoundingRadius = mdlView.getFloat32(mdlSubmodelIdx + 0x44, true);
                const mdlSubmodelNumMeshes = mdlView.getUint32(mdlSubmodelIdx + 0x48, true);
                const mdlSubmodelMeshindex = mdlView.getUint32(mdlSubmodelIdx + 0x4C, true);
                const mdlSubmodelNumvertices = mdlView.getUint32(mdlSubmodelIdx + 0x50, true);
                const mdlSubmodelVertexindex = mdlView.getUint32(mdlSubmodelIdx + 0x54, true);
                const mdlSubmodelTangentsindex = mdlView.getUint32(mdlSubmodelIdx + 0x58, true);
                const mdlSubmodelNumattachments = mdlView.getUint32(mdlSubmodelIdx + 0x5C, true);
                const mdlSubmodelAttachmentindex = mdlView.getUint32(mdlSubmodelIdx + 0x60, true);
                const mdlSubmodelNumeyeballs = mdlView.getUint32(mdlSubmodelIdx + 0x64, true);
                const mdlSubmodelEyeballindex = mdlView.getUint32(mdlSubmodelIdx + 0x68, true);

                // mstudio_modelvertexdata_t
                // const mdlSubmodelVertexDataPtr = mdlView.getUint32(mdlSubmodelIdx + 0x6C, true); junk pointer
                // const mdlSubmodelTangentsDataPtr = mdlView.getUint32(mdlSubmodelIdx + 0x70, true); junk pointer
                const vvdSubmodelVertexDataOffs = vvdVertexDataStart + mdlSubmodelVertexindex;
                const vvdSubmodelTangentDataOffs = vvdTangentDataStart + mdlSubmodelTangentsindex;

                // int unused[8];

                const vtxSubmodelNumLODs = vtxView.getUint32(vtxSubmodelIdx + 0x00, true);
                assert(vtxSubmodelNumLODs === vtxNumLODs);
                const vtxSubmodelLODOffset = vtxSubmodelIdx + vtxView.getUint32(vtxSubmodelIdx + 0x04, true);

                const submodelData = new StudioModelSubmodelData(mdlSubmodelName);
                bodyPartData.submodelData.push(submodelData);

                let vtxLODIdx = vtxSubmodelLODOffset;
                for (let lod = 0; lod < vtxSubmodelNumLODs; lod++) {
                    const vtxNumMeshes = vtxView.getUint32(vtxLODIdx + 0x00, true);
                    assert(vtxNumMeshes === mdlSubmodelNumMeshes);
                    const vtxMeshOffset = vtxView.getUint32(vtxLODIdx + 0x04, true);
                    const vtxSwitchPoint = vtxView.getFloat32(vtxLODIdx + 0x08, true);

                    const lodData = new StudioModelLODData();
                    submodelData.lodData.push(lodData);
                    let mdlMeshIdx = mdlSubmodelIdx + mdlSubmodelMeshindex;
                    let vtxMeshIdx = vtxLODIdx + vtxMeshOffset;
                    for (let m = 0; m < mdlSubmodelNumMeshes; m++) {
                        // MDL data is not LOD-specific, we reparse this for each LOD.
                        const material = mdlView.getUint32(mdlMeshIdx + 0x00, true);
                        const modelindex = mdlView.getUint32(mdlMeshIdx + 0x04, true);
                        const materialName = lodMaterialNames[lod][material];

                        const mdlMeshNumvertices = mdlView.getUint32(mdlMeshIdx + 0x08, true);
                        const mdlMeshVertexoffset = mdlView.getUint32(mdlMeshIdx + 0x0C, true);

                        const numflexes = mdlView.getUint32(mdlMeshIdx + 0x10, true);
                        const flexindex = mdlView.getUint32(mdlMeshIdx + 0x14, true);

                        const materialtype = mdlView.getUint32(mdlMeshIdx + 0x18, true);
                        assert(materialtype === 0); // not eyeballs
                        const materialparam = mdlView.getUint32(mdlMeshIdx + 0x1C, true);

                        const meshid = mdlView.getUint32(mdlMeshIdx + 0x20, true);
                        const centerX = mdlView.getFloat32(mdlMeshIdx + 0x24, true);
                        const centerY = mdlView.getFloat32(mdlMeshIdx + 0x28, true);
                        const centerZ = mdlView.getFloat32(mdlMeshIdx + 0x2C, true);

                        // mstudio_meshvertexdata_t
                        // const modelvertexdata = mdlView.getUint32(mdlMeshIdx + 0x30, true); junk pointer
                        const lodVertices = mdlView.getUint32(mdlMeshIdx + 0x34 + lod * 0x04, true);

                        // On the VTX side, each mesh contains a number of "strip groups". In theory, there can be up to
                        // four different strip groups for the 2x2 combinatoric matrix of "hw skin" and "is flex".
                        // We load the DX90 VTX files, which always have hw skin enabled, so we should see at most two
                        // flex groups.
                        const vtxNumStripGroups = vtxView.getUint32(vtxMeshIdx + 0x00, true);
                        assert(vtxNumStripGroups === 1 || vtxNumStripGroups === 2);
                        const vtxStripGroupHeaderOffset = vtxView.getUint32(vtxMeshIdx + 0x04, true);
                        const vtxMeshFlags = vtxView.getUint8(vtxMeshIdx + 0x08);

                        let meshNumVertices = 0;
                        let meshNumIndices = 0;
                        let vtxStripGroupIdx = vtxMeshIdx + vtxStripGroupHeaderOffset;
                        for (let g = 0; g < vtxNumStripGroups; g++) {
                            const numVerts = vtxView.getUint32(vtxStripGroupIdx + 0x00, true);
                            const numIndices = vtxView.getUint32(vtxStripGroupIdx + 0x08, true);
                            meshNumVertices += numVerts;
                            meshNumIndices += numIndices;
                        }

                        // 3 pos, 4 normal, 4 tangent, 2 uv
                        const vertexSize = (3+4+4+2);
                        const meshVtxData = new Float32Array(meshNumVertices * vertexSize);
                        const meshIdxData = new Uint16Array(meshNumIndices);

                        let dataOffs = 0x00;
                        let meshIdxBase = 0;
                        let idxOffs = 0x00;
                        let meshFirstIdx = 0;

                        const stripGroupDatas: StudioModelStripGroupData[] = [];

                        vtxStripGroupIdx = vtxMeshIdx + vtxStripGroupHeaderOffset;
                        for (let g = 0; g < vtxNumStripGroups; g++) {
                            const numVerts = vtxView.getUint32(vtxStripGroupIdx + 0x00, true);
                            const vertOffset = vtxView.getUint32(vtxStripGroupIdx + 0x04, true);

                            const numIndices = vtxView.getUint32(vtxStripGroupIdx + 0x08, true);
                            const indexOffset = vtxView.getUint32(vtxStripGroupIdx + 0x0C, true);

                            const numStrips = vtxView.getUint32(vtxStripGroupIdx + 0x10, true);
                            const stripOffset = vtxView.getUint32(vtxStripGroupIdx + 0x14, true);

                            const stripGroupFlags: OptimizeStripGroupFlags = vtxView.getUint8(vtxStripGroupIdx + 0x18);
                            // DX90 VTX models should always have hw skin enabled.
                            assert(!!(stripGroupFlags & OptimizeStripGroupFlags.IS_HWSKINNED));

                            // Build the vertex data for our strip group.
                            let vertIdx = vtxStripGroupIdx + vertOffset;
                            for (let v = 0; v < numVerts; v++) {
                                // VTX Bone weight data.
                                const vtxBoneWeightIdx0 = vtxView.getUint8(vertIdx + 0x00);
                                const vtxBoneWeightIdx1 = vtxView.getUint8(vertIdx + 0x01);
                                const vtxBoneWeightIdx2 = vtxView.getUint8(vertIdx + 0x02);
                                const vtxNumBones = vtxView.getUint8(vertIdx + 0x03);
                                assert(vtxNumBones === 0);

                                const vtxOrigMeshVertID = vtxView.getUint16(vertIdx + 0x04, true);
                                const vtxBoneID0 = vtxView.getUint8(vertIdx + 0x06);
                                const vtxBoneID1 = vtxView.getUint8(vertIdx + 0x07);
                                const vtxBoneID2 = vtxView.getUint8(vertIdx + 0x08);

                                // Pull out VVD vertex data.
                                const modelVertIndex = (mdlMeshVertexoffset + vtxOrigMeshVertID);
                                const vvdVertIndex = fixupRemappingSearch(fixupRemappings, modelVertIndex);
                                const vvdVertexOffs = vvdSubmodelVertexDataOffs + 0x30 * vvdVertIndex;
                                const vvdTangentOffs = vvdSubmodelTangentDataOffs + 0x10 * vvdVertIndex;

                                const vvdBoneWeight0 = vvdView.getFloat32(vvdVertexOffs + 0x00, true);
                                const vvdBoneWeight1 = vvdView.getFloat32(vvdVertexOffs + 0x04, true);
                                const vvdBoneWeight2 = vvdView.getFloat32(vvdVertexOffs + 0x08, true);
                                const vvdBoneIdx0 = vvdView.getUint8(vvdVertexOffs + 0x0C);
                                const vvdBoneIdx1 = vvdView.getUint8(vvdVertexOffs + 0x0D);
                                const vvdBoneIdx2 = vvdView.getUint8(vvdVertexOffs + 0x0E);
                                const vvdNumBones = vvdView.getUint8(vvdVertexOffs + 0x0F);

                                const vvdPositionX = vvdView.getFloat32(vvdVertexOffs + 0x10, true);
                                const vvdPositionY = vvdView.getFloat32(vvdVertexOffs + 0x14, true);
                                const vvdPositionZ = vvdView.getFloat32(vvdVertexOffs + 0x18, true);

                                const vvdNormalX = vvdView.getFloat32(vvdVertexOffs + 0x1C, true);
                                const vvdNormalY = vvdView.getFloat32(vvdVertexOffs + 0x20, true);
                                const vvdNormalZ = vvdView.getFloat32(vvdVertexOffs + 0x24, true);

                                const vvdTexCoordS = vvdView.getFloat32(vvdVertexOffs + 0x28, true);
                                const vvdTexCoordT = vvdView.getFloat32(vvdVertexOffs + 0x2C, true);

                                const vvdTangentSX = vvdView.getFloat32(vvdTangentOffs + 0x00, true);
                                const vvdTangentSY = vvdView.getFloat32(vvdTangentOffs + 0x04, true);
                                const vvdTangentSZ = vvdView.getFloat32(vvdTangentOffs + 0x08, true);
                                const vvdTangentSW = vvdView.getFloat32(vvdTangentOffs + 0x0C, true);

                                // Sanity check our tangent sign data.
                                // TODO(jstpierre): Check the tangent data validity against our material.
                                assert(vvdTangentSW === 0.0 || vvdTangentSW === 1.0 || vvdTangentSW === -1.0);

                                // Position
                                meshVtxData[dataOffs++] = vvdPositionX;
                                meshVtxData[dataOffs++] = vvdPositionY;
                                meshVtxData[dataOffs++] = vvdPositionZ;

                                // Normal
                                meshVtxData[dataOffs++] = vvdNormalX;
                                meshVtxData[dataOffs++] = vvdNormalY;
                                meshVtxData[dataOffs++] = vvdNormalZ;
                                meshVtxData[dataOffs++] = 1.0; // vertex alpha

                                // Tangent
                                meshVtxData[dataOffs++] = vvdTangentSX;
                                meshVtxData[dataOffs++] = vvdTangentSY;
                                meshVtxData[dataOffs++] = vvdTangentSZ;
                                meshVtxData[dataOffs++] = vvdTangentSW;

                                // Texcoord
                                meshVtxData[dataOffs++] = vvdTexCoordS;
                                meshVtxData[dataOffs++] = vvdTexCoordT;

                                vertIdx += 0x09;
                            }

                            let indexIdx = vtxStripGroupIdx + indexOffset;
                            for (let i = 0; i < numIndices; i++) {
                                meshIdxData[idxOffs++] = meshIdxBase + vtxView.getUint16(indexIdx, true);
                                indexIdx += 0x02;
                            }

                            meshIdxBase += numVerts;

                            const stripGroupData = new StudioModelStripGroupData();
                            stripGroupDatas.push(stripGroupData);

                            // Note that as noted before, "tristrip" in modern models refers mostly to trilists, not tristrips.
                            // We can have multiple strips in a strip group if we have a bone change table between strips.
                            // For unskinned / static prop models without bones, we should always have one strip.
                            // TODO(jstpierre): Handle skinned models.
                            let vtxStripIdx = vtxStripGroupIdx + stripOffset;
                            assert(numStrips === 1);
                            for (let s = 0; s < numStrips; s++) {
                                const stripNumIndices = vtxView.getUint32(vtxStripIdx + 0x00, true);
                                const stripIndexOffset = vtxView.getUint32(vtxStripIdx + 0x04, true);
                                assert(stripNumIndices === numIndices);
                                assert(stripIndexOffset === 0);

                                const stripNumVerts = vtxView.getUint32(vtxStripIdx + 0x08, true);
                                const stripVertOffset = vtxView.getUint32(vtxStripIdx + 0x0C, true);
                                assert(stripNumVerts === numVerts);
                                assert(stripVertOffset === 0);

                                const numBones = vtxView.getUint16(vtxStripIdx + 0x10, true);
                                assert(numBones === 0);

                                const stripFlags: OptimizeStripFlags = vtxView.getUint8(vtxStripIdx + 0x12);
                                assert(stripFlags === OptimizeStripFlags.IS_TRILIST);

                                const numBoneStateChanges = vtxView.getUint32(vtxStripIdx + 0x13, true);
                                const boneStateChangeOffset = vtxView.getUint32(vtxStripIdx + 0x17, true);
                                assert(numBoneStateChanges === 0);

                                stripGroupData.stripData.push(new StudioModelStripData(meshFirstIdx + stripIndexOffset, stripNumIndices));

                                vtxStripIdx += 0x1C;
                            }

                            meshFirstIdx += numIndices;

                            vtxStripGroupIdx += 0x1C;
                        }

                        const device = renderContext.device, cache = renderContext.cache;
                        const meshData = new StudioModelMeshData(device, cache, materialName, meshVtxData.buffer, meshIdxData.buffer);
                        for (let i = 0; i < stripGroupDatas.length; i++)
                            meshData.stripGroupData.push(stripGroupDatas[i]);
                        lodData.meshData.push(meshData);

                        mdlMeshIdx += 0x74;
                        vtxMeshIdx += 0x09;
                    }

                    vtxLODIdx += 0x0C;

                    // TODO(jstpierre): Support multiple model LODs. For now, we only support the first LOD.
                    break;
                }

                mdlSubmodelIdx += 0x94;
                vtxSubmodelIdx += 0x08;
            }

            mdlBodyPartIdx += 0x10;
            vtxBodyPartIdx += 0x08;
        }
    }

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.bodyPartData.length; i++)
            this.bodyPartData[i].destroy(device);
    }
}

// Hardware verts, used for static color data

interface HardwareVertDataMesh {
    lod: number;
    indexInsideLOD: number;
    vertexCount: number;
    byteOffset: number;
    byteSize: number;
}

export class HardwareVertData {
    public checksum: number;
    public buffer: GfxBuffer;
    public mesh: HardwareVertDataMesh[] = [];

    constructor(renderContext: SourceRenderContext, buffer: ArrayBufferSlice) {
        const view = buffer.createDataView();

        const version = view.getUint32(0x00, true);
        assert(version === 0x02);

        this.checksum = view.getUint32(0x04, true);

        // Hardware verts are used solely for vertex colors

        const enum VertexFlags { POSITION = 0x01, NORMAL = 0x02, COLOR = 0x04, SPECULAR = 0x08, TANGENT_S = 0x10, TANGENT_T = 0x20, }
        const vertexFlags: VertexFlags = view.getUint32(0x08, true);
        assert(vertexFlags === VertexFlags.COLOR);

        const vertexSize: number = view.getUint32(0x0C, true);
        assert(vertexSize === 4);

        const vertexCount = view.getUint32(0x10, true);

        const numMeshes = view.getUint32(0x14, true);

        // 0x10 bytes of padding.
        const vertexData = new Uint8Array(vertexCount * 4);
        let vertexOffs = 0;

        let lastLOD = -1;
        let indexInsideLOD = 0;

        let meshHeaderIdx = 0x28;
        for (let i = 0; i < numMeshes; i++) {
            const lod = view.getUint32(meshHeaderIdx + 0x00, true);
            if (lastLOD !== lod) {
                indexInsideLOD = 0;
                lastLOD = lod;
            }

            const meshVertexCount = view.getUint32(meshHeaderIdx + 0x04, true);
            const offset = view.getUint32(meshHeaderIdx + 0x08, true);

            const meshByteSize = meshVertexCount * 4;

            this.mesh.push({ lod, indexInsideLOD, vertexCount: meshVertexCount, byteOffset: vertexOffs, byteSize: meshByteSize });

            // Input and output data are both RGBA
            // Input is BGRA, we need RGBA
            let dataOffs = offset;
            for (let i = 0; i < meshVertexCount; i++) {
                const b = view.getUint8(dataOffs++);
                const g = view.getUint8(dataOffs++);
                const r = view.getUint8(dataOffs++);
                const a = view.getUint8(dataOffs++);
                vertexData[vertexOffs++] = r;
                vertexData[vertexOffs++] = g;
                vertexData[vertexOffs++] = b;
                vertexData[vertexOffs++] = a;
            }

            // 0x10 bytes of padding.
            meshHeaderIdx += 0x1C;
        }

        this.buffer = makeStaticDataBuffer(renderContext.device, GfxBufferUsage.VERTEX, vertexData.buffer);
    }

    public destroy(device: GfxDevice): void {
        device.destroyBuffer(this.buffer);
    }
}

export class StudioModelCache {
    private modelData: StudioModelData[] = [];
    private modelDataPromiseCache = new Map<string, Promise<StudioModelData>>();

    constructor(private renderContext: SourceRenderContext, private filesystem: SourceFileSystem) {
    }

    private resolvePath(path: string, ext: string): string {
        if (path.endsWith('.mdl'))
            path = path.slice(0, -4);
        if (!path.endsWith(ext))
            path = `${path}${ext}`;
        return this.filesystem.resolvePath(path, ext);
    }

    private async fetchStudioModelDataInternal(name: string): Promise<StudioModelData> {
        const mdlPath = this.resolvePath(name, '.mdl');
        const vvdPath = this.resolvePath(name, '.vvd');
        const vtxPath = this.resolvePath(name, '.dx90.vtx');
        const [mdlBuffer, vvdBuffer, vtxBuffer] = await Promise.all([
            this.filesystem.fetchFileData(mdlPath),
            this.filesystem.fetchFileData(vvdPath),
            this.filesystem.fetchFileData(vtxPath),
        ]);
        const modelData = new StudioModelData(this.renderContext, mdlBuffer!, vvdBuffer!, vtxBuffer!);
        this.modelData.push(modelData);
        return modelData;
    }

    public fetchStudioModelData(path: string): Promise<StudioModelData> {
        if (!this.modelDataPromiseCache.has(path))
            this.modelDataPromiseCache.set(path, this.fetchStudioModelDataInternal(path));
        return this.modelDataPromiseCache.get(path)!;
    }

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.modelData.length; i++)
            this.modelData[i].destroy(device);
    }
}

class StudioModelMeshInstance {
    private visible = true;
    private materialInstance: BaseMaterial | null = null;
    private inputStateWithColorMesh: GfxInputState | null = null;

    constructor(renderContext: SourceRenderContext, private meshData: StudioModelMeshData, entityParams: EntityMaterialParameters) {
        this.bindMaterial(renderContext, entityParams);
    }

    private syncMaterialInstanceStaticLightingMode(): void {
        if (this.materialInstance !== null) {
            const staticLightingMode = (this.inputStateWithColorMesh !== null) ? StaticLightingMode.StudioVertexLighting : StaticLightingMode.StudioAmbientCube;
            this.materialInstance.setStaticLightingMode(staticLightingMode);
        }
    }

    private async bindMaterial(renderContext: SourceRenderContext, entityParams: EntityMaterialParameters): Promise<void> {
        this.materialInstance = await renderContext.materialCache.createMaterialInstance(renderContext, this.meshData.materialName, entityParams);
        this.syncMaterialInstanceStaticLightingMode();
    }

    public bindColorMeshData(device: GfxDevice, data: HardwareVertData, mesh: HardwareVertDataMesh): void {
        assert(this.inputStateWithColorMesh === null);

        const colorDescriptor: GfxVertexBufferDescriptor = { buffer: data.buffer, byteOffset: mesh.byteOffset };
        this.inputStateWithColorMesh = this.meshData.createInputStateWithColorMesh(device, colorDescriptor);

        this.syncMaterialInstanceStaticLightingMode();
    }

    public movement(renderContext: SourceRenderContext): void {
        if (!this.visible || this.materialInstance === null)
            return;

        this.materialInstance.movement(renderContext);
    }

    public prepareToRender(renderContext: SourceRenderContext, renderInstManager: GfxRenderInstManager, modelMatrix: mat4) {
        if (!this.visible || this.materialInstance === null || !this.materialInstance.visible || !this.materialInstance.isMaterialLoaded())
            return;

        const template = renderInstManager.pushTemplateRenderInst();
        this.materialInstance.setOnRenderInst(renderContext, template, modelMatrix);

        // Bind color mesh if we have a per-instance version.
        if (this.inputStateWithColorMesh !== null)
            template.setInputLayoutAndState(this.meshData.inputLayoutWithColorMesh, this.inputStateWithColorMesh);
        else
            template.setInputLayoutAndState(this.meshData.inputLayoutWithoutColorMesh, this.meshData.inputStateWithoutColorMesh);

        for (let i = 0; i < this.meshData.stripGroupData.length; i++) {
            const stripGroupData = this.meshData.stripGroupData[i];

            for (let j = 0; j < stripGroupData.stripData.length; j++) {
                const stripData = stripGroupData.stripData[j];
                const renderInst = renderInstManager.newRenderInst();
                renderInst.drawIndexes(stripData.indexCount, stripData.firstIndex);
                renderInstManager.submitRenderInst(renderInst);
            }
        }

        renderInstManager.popTemplateRenderInst();
    }

    public destroy(device: GfxDevice): void {
        if (this.inputStateWithColorMesh !== null)
            device.destroyInputState(this.inputStateWithColorMesh);
    }
}

class StudioModelLODInstance {
    public meshInstance: StudioModelMeshInstance[] = [];

    constructor(renderContext: SourceRenderContext, private lodData: StudioModelLODData, entityParams: EntityMaterialParameters) {
        for (let i = 0; i < this.lodData.meshData.length; i++)
            this.meshInstance.push(new StudioModelMeshInstance(renderContext, this.lodData.meshData[i], entityParams));
    }

    public movement(renderContext: SourceRenderContext): void {
        for (let i = 0; i < this.meshInstance.length; i++)
            this.meshInstance[i].movement(renderContext);
    }

    public prepareToRender(renderContext: SourceRenderContext, renderInstManager: GfxRenderInstManager, modelMatrix: mat4) {
        for (let i = 0; i < this.meshInstance.length; i++)
            this.meshInstance[i].prepareToRender(renderContext, renderInstManager, modelMatrix);
    }

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.meshInstance.length; i++)
            this.meshInstance[i].destroy(device);
    }
}

export class StudioModelInstance {
    public visible: boolean = true;
    public modelMatrix = mat4.create();

    private lodInstance: StudioModelLODInstance[] = [];

    constructor(renderContext: SourceRenderContext, private modelData: StudioModelData, materialParams: EntityMaterialParameters) {
        assert(this.modelData.bodyPartData.length === 1);
        const bodyPartData = this.modelData.bodyPartData[0];

        assert(bodyPartData.submodelData.length === 1);
        const submodelData = bodyPartData.submodelData[0];

        for (let k = 0; k < submodelData.lodData.length; k++) {
            const lodData = submodelData.lodData[k];
            this.lodInstance.push(new StudioModelLODInstance(renderContext, lodData, materialParams));
        }
    }

    public setColorMeshData(device: GfxDevice, data: HardwareVertData): void {
        // In some TF2 games, checksums don't match. For now, apply the static lighting anyway,
        // as it won't look as bad as unlit models. If/when we do proper lighting for light probes,
        // then this can go away.

        // if (data.checksum !== this.modelData.checksum)
        //     return;

        for (let i = 0; i < this.lodInstance.length; i++) {
            const lodInstance = this.lodInstance[i];
            for (let j = 0; j < lodInstance.meshInstance.length; j++) {
                const meshInstance = lodInstance.meshInstance[j];

                // Find proper color mesh.
                const colorMesh = data.mesh.find((mesh) => mesh.lod === i && mesh.indexInsideLOD === j);
                if (colorMesh === undefined)
                    continue;

                meshInstance.bindColorMeshData(device, data, colorMesh);
            }
        }
    }

    private getLODModelIndex(renderContext: SourceRenderContext): number {
        // TODO(jstpierre): Pull out the proper LOD model.
        return 0;
    }

    public movement(renderContext: SourceRenderContext): void {
        const lodIndex = this.getLODModelIndex(renderContext);
        this.lodInstance[lodIndex].movement(renderContext);
    }

    public prepareToRender(renderContext: SourceRenderContext, renderInstManager: GfxRenderInstManager) {
        if (!this.visible)
            return;

        const lodIndex = this.getLODModelIndex(renderContext);
        this.lodInstance[lodIndex].prepareToRender(renderContext, renderInstManager, this.modelMatrix);
    }

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.lodInstance.length; i++)
            this.lodInstance[i].destroy(device);
    }
}


// Source "Studio" models, which seem to be named because of their original ties to 3D Studio Max
// https://developer.valvesoftware.com/wiki/Studiomodel

import ArrayBufferSlice from "../ArrayBufferSlice";
import { GfxDevice, GfxBuffer, GfxInputLayout, GfxInputState, GfxBufferUsage, GfxVertexAttributeDescriptor, GfxFormat, GfxInputLayoutBufferDescriptor, GfxVertexBufferFrequency, GfxVertexBufferDescriptor } from "../gfx/platform/GfxPlatform";
import { assert, readString, nArray, assertExists } from "../util";
import { SourceFileSystem, SourceRenderContext } from "./Main";
import { AABB } from "../Geometry";
import { GfxRenderCache } from "../gfx/render/GfxRenderCache";
import { makeStaticDataBuffer } from "../gfx/helpers/BufferHelpers";
import { MaterialProgramBase, BaseMaterial, EntityMaterialParameters, StaticLightingMode, SkinningMode } from "./Materials";
import { GfxRenderInstManager } from "../gfx/render/GfxRenderer";
import { mat4, ReadonlyMat4, ReadonlyVec3, vec3 } from "gl-matrix";
import { MathConstants } from "../MathHelpers";

// Encompasses the MDL, VVD & VTX formats.

const enum StudioModelFlags {
    AUTOGENERATED_HITBOX           = 0x0001,
    FORCE_OPAQUE                   = 0x0004,
    STATIC_PROP                    = 0x0010,
    CONSTANT_DIRECTIONAL_LIGHT_DOT = 0x2000,
}

const enum OptimizeStripGroupFlags {
    IS_FLEXED                      = 0x01,
    IS_HWSKINNED                   = 0x02,
    IS_DELTA_FLEXED                = 0x04,
}

const enum OptimizeStripFlags {
    IS_TRILIST                     = 0x01,
    IS_TRISTRIP                    = 0x02,
}

function computeModelMatrixPosRotInternal(dst: mat4, pitch: number, yaw: number, roll: number, pos: ReadonlyVec3): void {
    // Pitch, Yaw, Roll
    // https://github.com/ValveSoftware/source-sdk-2013/blob/master/sp/src/mathlib/mathlib_base.cpp#L1218-L1233

    const sinP = Math.sin(pitch), cosP = Math.cos(pitch);
    const sinY = Math.sin(yaw),   cosY = Math.cos(yaw);
    const sinR = Math.sin(roll),  cosR = Math.cos(roll);

    dst[0] =  (cosP * cosY);
    dst[1] =  (cosP * sinY);
    dst[2] =  (-sinP);
    dst[3] =  0.0;

    dst[4] =  (sinP * sinR * cosY - cosR * sinY);
    dst[5] =  (sinP * sinR * sinY + cosR * cosY);
    dst[6] =  (sinR * cosP);
    dst[7] =  0.0;

    dst[8] =  (sinP * cosR * cosY + sinR * sinY);
    dst[9] =  (sinP * cosR * sinY - sinR * cosY);
    dst[10] = (cosR * cosP);
    dst[11] = 0.0;

    dst[12] = pos[0];
    dst[13] = pos[1];
    dst[14] = pos[2];
    dst[15] = 1.0;
}

export function computeModelMatrixPosQAngle(dst: mat4, pos: ReadonlyVec3, qangle: ReadonlyVec3): void {
    // QAngle is in degrees.
    const pitch = qangle[0] * MathConstants.DEG_TO_RAD;
    const yaw =   qangle[1] * MathConstants.DEG_TO_RAD;
    const roll =  qangle[2] * MathConstants.DEG_TO_RAD;
    computeModelMatrixPosRotInternal(dst, pitch, yaw, roll, pos);
}

function computeModelMatrixPosRadianEuler(dst: mat4, pos: ReadonlyVec3, radianEuler: ReadonlyVec3): void {
    // Convert Euler angles to PYR.
    // https://github.com/ValveSoftware/source-sdk-2013/blob/master/sp/src/mathlib/mathlib_base.cpp#L1182
    const pitch = radianEuler[1];
    const yaw =   radianEuler[2];
    const roll =  radianEuler[0];
    computeModelMatrixPosRotInternal(dst, pitch, yaw, roll, pos);
}

class StudioModelStripData {
    constructor(public firstIndex: number, public indexCount: number, public hardwareBoneTable: number[]) {
    }
}

class StudioModelStripGroupData {
    public stripData: StudioModelStripData[] = [];

    constructor() {
    }
}

// TODO(jstpierre): Coalesce all buffers for a studio model?
class StudioModelMeshData {
    public vertexBuffer: GfxBuffer;
    public indexBuffer: GfxBuffer;
    public inputLayoutWithoutColorMesh: GfxInputLayout;
    public inputStateWithoutColorMesh: GfxInputState;
    public inputLayoutWithColorMesh: GfxInputLayout;

    public stripGroupData: StudioModelStripGroupData[] = [];

    constructor(device: GfxDevice, cache: GfxRenderCache, public materialName: string, vertexData: ArrayBuffer, indexData: ArrayBuffer) {
        this.vertexBuffer = makeStaticDataBuffer(device, GfxBufferUsage.VERTEX, vertexData);
        this.indexBuffer = makeStaticDataBuffer(device, GfxBufferUsage.INDEX, indexData);

        // TODO(jstpierre): Lighten up vertex buffers by only allocating bone weights / IDs if necessary?
        const vertexAttributeDescriptors: GfxVertexAttributeDescriptor[] = [
            { location: MaterialProgramBase.a_Position,    bufferIndex: 0, bufferByteOffset: 0*0x04, format: GfxFormat.F32_RGB, },
            { location: MaterialProgramBase.a_Normal,      bufferIndex: 0, bufferByteOffset: 3*0x04, format: GfxFormat.F32_RGBA, },
            { location: MaterialProgramBase.a_TangentS,    bufferIndex: 0, bufferByteOffset: 7*0x04, format: GfxFormat.F32_RGBA, },
            { location: MaterialProgramBase.a_TexCoord,    bufferIndex: 0, bufferByteOffset: 11*0x04, format: GfxFormat.F32_RG, },
            { location: MaterialProgramBase.a_BoneWeights, bufferIndex: 0, bufferByteOffset: 13*0x04, format: GfxFormat.F32_RGBA, },
            { location: MaterialProgramBase.a_BoneIDs,     bufferIndex: 0, bufferByteOffset: 17*0x04, format: GfxFormat.F32_RGBA, },
        ];
        const vertexBufferDescriptors: GfxInputLayoutBufferDescriptor[] = [
            { byteStride: (3+4+4+2+4+4)*0x04, frequency: GfxVertexBufferFrequency.PER_VERTEX, },
        ];
        const indexBufferFormat = GfxFormat.U16_R;
        this.inputLayoutWithoutColorMesh = cache.createInputLayout(device, { vertexAttributeDescriptors, vertexBufferDescriptors, indexBufferFormat });

        // Tack on the color mesh.
        vertexAttributeDescriptors.push(
            { location: MaterialProgramBase.a_StaticVertexLighting, bufferIndex: 1, bufferByteOffset: 0*0x04, format: GfxFormat.U8_RGBA_NORM, },
        );
        vertexBufferDescriptors.push(
            { byteStride: 0x04,           frequency: GfxVertexBufferFrequency.PER_VERTEX, },
        );
        this.inputLayoutWithColorMesh = cache.createInputLayout(device, { vertexAttributeDescriptors, vertexBufferDescriptors, indexBufferFormat });

        // Create our base input state.
        this.inputStateWithoutColorMesh = device.createInputState(this.inputLayoutWithoutColorMesh, [
            { buffer: this.vertexBuffer, byteOffset: 0, },
        ], { buffer: this.indexBuffer, byteOffset: 0, });
    }

    public createInputStateWithColorMesh(device: GfxDevice, meshBufferDescriptor: GfxVertexBufferDescriptor): GfxInputState {
        return device.createInputState(this.inputLayoutWithColorMesh, [
            { buffer: this.vertexBuffer, byteOffset: 0, },
            meshBufferDescriptor,
        ], { buffer: this.indexBuffer, byteOffset: 0, });
    }

    public destroy(device: GfxDevice): void {
        device.destroyBuffer(this.vertexBuffer);
        device.destroyBuffer(this.indexBuffer);
        device.destroyInputState(this.inputStateWithoutColorMesh);
    }
}

class StudioModelLODData {
    public meshData: StudioModelMeshData[] = [];

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.meshData.length; i++)
            this.meshData[i].destroy(device);
    }
}

class StudioModelSubmodelData {
    public lodData: StudioModelLODData[] = [];

    constructor(public name: string) {
    }

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.lodData.length; i++)
            this.lodData[i].destroy(device);
    }
}

class StudioModelBodyPartData {
    public submodelData: StudioModelSubmodelData[] = [];

    constructor(private name: string) {
    }

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.submodelData.length; i++)
            this.submodelData[i].destroy(device);
    }
}

interface FixupRemapping { copySrc: number; copyDst: number; count: number; }
function fixupRemappingSearch(fixupTable: FixupRemapping[], dstIdx: number): number {
    for (let i = 0; i < fixupTable.length; i++) {
        const map = fixupTable[i];
        const idx = dstIdx - map.copyDst;
        if (idx >= 0 && idx < map.count)
            return map.copySrc + idx;
    }

    // remap did not copy over this vertex, return as is.
    return dstIdx;
}

/*
class ResizableArrayBuffer {
    private buffer: ArrayBuffer;
    private byteSize: number;
    private byteCapacity: number;

    constructor(initialSize: number = 0x400) {
        this.byteSize = 0;
        this.byteCapacity = initialSize;
        this.buffer = new ArrayBuffer(initialSize);
    }

    public ensureSize(byteSize: number): void {
        this.byteSize = byteSize;

        if (byteSize > this.byteCapacity) {
            this.byteCapacity = Math.max(byteSize, this.byteCapacity * 2);
            const oldBuffer = this.buffer;
            const newBuffer = new ArrayBuffer(this.byteCapacity);
            new Uint8Array(newBuffer).set(new Uint8Array(oldBuffer));
            this.buffer = newBuffer;
        }
    }

    public addByteSize(byteSize: number): void {
        this.ensureSize(this.byteSize + byteSize);
    }

    public addUint16(count: number): [number, Uint16Array] {
        const offs = this.byteSize;
        this.addByteSize(count << 1);
        return [offs >>> 1, new Uint16Array(this.buffer, offs, count)];
    }

    public addFloat32(count: number): [number, Float32Array] {
        const offs = this.byteSize;
        this.addByteSize(count << 2);
        return [offs >>> 2, new Float32Array(this.buffer, offs, count)];
    }

    public finalize(): ArrayBuffer {
        return ArrayBuffer_slice.call(this.buffer, 0, this.byteSize);
    }
}
*/

class Bone {
    public pos = vec3.create();
    public rot = vec3.create();
    public poseToBone = mat4.create();

    constructor(private name: string, public parent: number) {
    }
}

export class StudioModelData {
    private name: string;

    public bodyPartData: StudioModelBodyPartData[] = [];
    public checksum: number;
    public bbox: AABB;
    public bones: Bone[] = [];

    constructor(renderContext: SourceRenderContext, mdlBuffer: ArrayBufferSlice, vvdBuffer: ArrayBufferSlice, vtxBuffer: ArrayBufferSlice) {
        const mdlView = mdlBuffer.createDataView();

        // We have three separate files of data (MDL, VVD, VTX) to chew through.
        //
        // MDL = Studio Model Header, contains skeleton, most aux data, animations, etc.
        // VVD = Valve Vertex Data, contains actual vertex data.
        // VTX = Optimized Model, contains per-LOD information (index buffer, optimized trilist information & material replacement).

        // Parse MDL header
        assert(readString(mdlBuffer, 0x00, 0x04) === 'IDST');
        const mdlVersion = mdlView.getUint32(0x04, true);

        const supportedVersions = [44, 45, 46, 47, 48];
        assert(supportedVersions.includes(mdlVersion));

        this.checksum = mdlView.getUint32(0x08, true);

        this.name = readString(mdlBuffer, 0x0C, 0x40, true);
        const length = mdlView.getUint32(0x4C, true);

        const eyePositionX = mdlView.getFloat32(0x50, true);
        const eyePositionY = mdlView.getFloat32(0x54, true);
        const eyePositionZ = mdlView.getFloat32(0x58, true);

        const illumPositionX = mdlView.getFloat32(0x5C, true);
        const illumPositionY = mdlView.getFloat32(0x60, true);
        const illumPositionZ = mdlView.getFloat32(0x64, true);

        const moveHullMinX = mdlView.getFloat32(0x68, true);
        const moveHullMinY = mdlView.getFloat32(0x6C, true);
        const moveHullMinZ = mdlView.getFloat32(0x70, true);
        const moveHullMaxX = mdlView.getFloat32(0x74, true);
        const moveHullMaxY = mdlView.getFloat32(0x78, true);
        const moveHullMaxZ = mdlView.getFloat32(0x7C, true);

        const bboxMinX = mdlView.getFloat32(0x80, true);
        const bboxMinY = mdlView.getFloat32(0x84, true);
        const bboxMinZ = mdlView.getFloat32(0x88, true);
        const bboxMaxX = mdlView.getFloat32(0x8C, true);
        const bboxMaxY = mdlView.getFloat32(0x90, true);
        const bboxMaxZ = mdlView.getFloat32(0x94, true);
        this.bbox = new AABB(bboxMinX, bboxMinY, bboxMinZ, bboxMaxX, bboxMaxY, bboxMaxZ);

        const flags: StudioModelFlags = mdlView.getUint32(0x98, true);
        const isStaticProp = !!(flags & StudioModelFlags.STATIC_PROP);

        const numbones = mdlView.getUint32(0x9C, true);
        const boneindex = mdlView.getUint32(0xA0, true);

        let boneidx = boneindex;
        for (let i = 0; i < numbones; i++) {
            const szname = readString(mdlBuffer, boneidx + mdlView.getUint32(boneidx + 0x00, true));
            const parent = mdlView.getInt32(boneidx + 0x04, true);
            assert(parent < i);
            const bone = new Bone(szname, parent);

            const bonecontroller = [
                mdlView.getInt32(boneidx + 0x08, true),
                mdlView.getInt32(boneidx + 0x0C, true),
                mdlView.getInt32(boneidx + 0x10, true),
                mdlView.getInt32(boneidx + 0x14, true),
                mdlView.getInt32(boneidx + 0x18, true),
                mdlView.getInt32(boneidx + 0x1C, true),
            ];

            bone.pos[0] = mdlView.getFloat32(boneidx + 0x20, true);
            bone.pos[1] = mdlView.getFloat32(boneidx + 0x24, true);
            bone.pos[2] = mdlView.getFloat32(boneidx + 0x28, true);
            const quatX = mdlView.getFloat32(boneidx + 0x2C, true);
            const quatY = mdlView.getFloat32(boneidx + 0x30, true);
            const quatZ = mdlView.getFloat32(boneidx + 0x34, true);
            const quatW = mdlView.getFloat32(boneidx + 0x38, true);
            bone.rot[0] = mdlView.getFloat32(boneidx + 0x3C, true);
            bone.rot[1] = mdlView.getFloat32(boneidx + 0x40, true);
            bone.rot[2] = mdlView.getFloat32(boneidx + 0x44, true);

            if (i === 0) {
                // XXX(jstpierre): Empirically, we seem to need some extra "oomph" on the root bone's Z rotation.
                // I have no clue why this is necessary.
                bone.rot[2] += MathConstants.TAU / 4;
            }

            const posScaleX = mdlView.getFloat32(boneidx + 0x48, true);
            const posScaleY = mdlView.getFloat32(boneidx + 0x4C, true);
            const posScaleZ = mdlView.getFloat32(boneidx + 0x50, true);
            const rotScaleX = mdlView.getFloat32(boneidx + 0x54, true);
            const rotScaleY = mdlView.getFloat32(boneidx + 0x58, true);
            const rotScaleZ = mdlView.getFloat32(boneidx + 0x5C, true);

            const poseToBone00 = mdlView.getFloat32(boneidx + 0x60, true);
            const poseToBone01 = mdlView.getFloat32(boneidx + 0x64, true);
            const poseToBone02 = mdlView.getFloat32(boneidx + 0x68, true);
            const poseToBone03 = mdlView.getFloat32(boneidx + 0x6C, true);
            const poseToBone10 = mdlView.getFloat32(boneidx + 0x70, true);
            const poseToBone11 = mdlView.getFloat32(boneidx + 0x74, true);
            const poseToBone12 = mdlView.getFloat32(boneidx + 0x78, true);
            const poseToBone13 = mdlView.getFloat32(boneidx + 0x7C, true);
            const poseToBone20 = mdlView.getFloat32(boneidx + 0x80, true);
            const poseToBone21 = mdlView.getFloat32(boneidx + 0x84, true);
            const poseToBone22 = mdlView.getFloat32(boneidx + 0x88, true);
            const poseToBone23 = mdlView.getFloat32(boneidx + 0x8C, true);
            mat4.set(bone.poseToBone,
                poseToBone00, poseToBone10, poseToBone20, 0,
                poseToBone01, poseToBone11, poseToBone21, 0,
                poseToBone02, poseToBone12, poseToBone22, 0,
                poseToBone03, poseToBone13, poseToBone23, 1,
            );

            const alignmentX = mdlView.getFloat32(boneidx + 0x90, true);
            const alignmentY = mdlView.getFloat32(boneidx + 0x94, true);
            const alignmentZ = mdlView.getFloat32(boneidx + 0x98, true);
            const alignmentW = mdlView.getFloat32(boneidx + 0x9C, true);

            const proctype = mdlView.getUint32(boneidx + 0xA4, true);
            const procindex = mdlView.getUint32(boneidx + 0xA8, true);
            const physicsbone = mdlView.getUint32(boneidx + 0xAC, true);
            const surfacepropidx = mdlView.getUint32(boneidx + 0xB0, true);
            const contents = mdlView.getUint32(boneidx + 0xB4, true);

            // int unused[8];

            this.bones.push(bone);
            boneidx += 0xD8;
        }

        const numbonecontrollers = mdlView.getUint32(0xA4, true);
        const bonecontrollerindex = mdlView.getUint32(0xA8, true);
        if (isStaticProp)
            assert(numbonecontrollers === 0);

        const numhitboxsets = mdlView.getUint32(0xAC, true);
        const hitboxsetindex = mdlView.getUint32(0xB0, true);

        const numlocalanims = mdlView.getUint32(0xB4, true);
        const localanimindex = mdlView.getUint32(0xB8, true);

        const numlocalseqs = mdlView.getUint32(0xBC, true);
        const localseqindex = mdlView.getUint32(0xC0, true);

        const activitylistversion = mdlView.getUint32(0xC4, true);
        const eventsindexed = mdlView.getUint32(0xC8, true);

        const numtextures = mdlView.getUint32(0xCC, true);
        const textureindex = mdlView.getUint32(0xD0, true);

        const numcdtextures = mdlView.getUint32(0xD4, true);
        const cdtextureindex = mdlView.getUint32(0xD8, true);

        const materialSearchDirs: string[] = [];
        let cdtextureIdx = cdtextureindex;
        for (let i = 0; i < numcdtextures; i++) {
            const textureDir = readString(mdlBuffer, mdlView.getUint32(cdtextureIdx + 0x00, true));
            const materialSearchDir = `materials/${textureDir}`;
            materialSearchDirs.push(materialSearchDir);
            cdtextureIdx += 0x04;
        }

        const numskinref = mdlView.getUint32(0xDC, true);
        const numskinfamilies = mdlView.getUint32(0xE0, true);
        const skinindex = mdlView.getUint32(0xE4, true);

        const numbodyparts = mdlView.getUint32(0xE8, true);
        const bodypartindex = mdlView.getUint32(0xEC, true);

        const numlocalattachments = mdlView.getUint32(0xF0, true);
        const localattachmentindex = mdlView.getUint32(0xF4, true);

        const numlocalnodes = mdlView.getUint32(0xF8, true);
        const localnodeindex = mdlView.getUint32(0xFC, true);
        const localnodenameindex = mdlView.getUint32(0x100, true);

        const numflexdesc = mdlView.getUint32(0x104, true);
        const flexdescindex = mdlView.getUint32(0x108, true);

        const numflexcontrollers = mdlView.getUint32(0x10C, true);
        const flexcontrollerindex = mdlView.getUint32(0x110, true);

        const numflexrules = mdlView.getUint32(0x114, true);
        const flexruleindex = mdlView.getUint32(0x118, true);

        const numikchains = mdlView.getUint32(0x11C, true);
        const ikchainindex = mdlView.getUint32(0x120, true);

        const nummouthss = mdlView.getUint32(0x124, true);
        const mouthsindex = mdlView.getUint32(0x128, true);

        const numlocalposeparameters = mdlView.getUint32(0x12C, true);
        const localposeparamindex = mdlView.getUint32(0x130, true);

        const surfacepropindex = mdlView.getUint32(0x134, true);
        const surfaceprop = readString(mdlBuffer, surfacepropindex);

        const keyvalueindex = mdlView.getUint32(0x138, true);
        const keyvaluesize = mdlView.getUint32(0x13C, true);

        const numlocalikautoplaylocks = mdlView.getUint32(0x140, true);
        const localikautoplaylockindex = mdlView.getUint32(0x144, true);

        const mass = mdlView.getFloat32(0x148, true);
        const contents = mdlView.getUint32(0x14C, true);

        const numincludemodels = mdlView.getUint32(0x150, true);
        const includemodelindex = mdlView.getUint32(0x154, true);

        // Runtime backpointer.
        const virtualModel = mdlView.getUint32(0x158, true);
        assert(virtualModel === 0);

        const animblocknameindex = mdlView.getUint32(0x15C, true);
        const numanimblocks = mdlView.getUint32(0x160, true);
        const animblockindex = mdlView.getUint32(0x164, true);
        const animblockModel = mdlView.getUint32(0x168, true);

        const bonetablebynameindex = mdlView.getUint32(0x16C, true);

        // Runtime backpointer.
        const vertexBase = mdlView.getUint32(0x170, true);
        const indexBase = mdlView.getUint32(0x174, true);
        assert(vertexBase === 0);
        assert(indexBase === 0);

        const constantdirectionallightdot = mdlView.getUint32(0x178, true);
        const rootLOD = mdlView.getUint32(0x179, true);
        const numAllowedRootLODs = mdlView.getUint32(0x17A, true);

        const numflexcontrollerui = mdlView.getUint32(0x180, true);
        const flexcontrollleruiindex = mdlView.getUint32(0x184, true);

        const vertAnimFixedPointScale = mdlView.getFloat32(0x188, true);
        const studiohdr2index = mdlView.getUint32(0x190, true);

        // Parse VVD header
        const vvdView = vvdBuffer.createDataView();

        assert(readString(vvdBuffer, 0x00, 0x04) === 'IDSV');
        const vvdVersion = vvdView.getUint32(0x04, true);
        assert(vvdVersion === 0x04);
        const vvdChecksum = vvdView.getUint32(0x08, true);
        assert(vvdChecksum === this.checksum);
        const vvdNumLODs = vvdView.getUint32(0x0C, true);
        const vvdNumLODVertexes = nArray(8, (i) => vvdView.getUint32(0x10 + i * 0x04, true));
        const vvdNumFixups = vvdView.getUint32(0x30, true);
        const vvdFixupTableStart = vvdView.getUint32(0x34, true);
        const vvdVertexDataStart = vvdView.getUint32(0x38, true);
        const vvdTangentDataStart = vvdView.getUint32(0x3C, true);

        const fixupRemappings: FixupRemapping[] = [];
        let vvdFixupTableIdx = vvdFixupTableStart;
        let fixupTableCopyDstIdx = 0;
        for (let i = 0; i < vvdNumFixups; i++) {
            const lod = vvdView.getUint32(vvdFixupTableIdx + 0x00, true);
            // The fixup table works by memcpy-ing vertex data from src -> dst. So the indices in the
            // MDL/VTX files are in copyDst range, and the vertices in the VVD file are in copySrc.
            const copySrc = vvdView.getUint32(vvdFixupTableIdx + 0x04, true);
            const copyDst = fixupTableCopyDstIdx;
            const count = vvdView.getUint32(vvdFixupTableIdx + 0x08, true);
            fixupRemappings.push({ copySrc, copyDst, count });
            fixupTableCopyDstIdx += count;
            vvdFixupTableIdx += 0x0C;
        }

        // Parse VTX header
        const vtxView = vtxBuffer.createDataView();

        const vtxVersion = vtxView.getUint32(0x00, true);
        assert(vtxVersion === 0x07);

        // VTX optimization settings.
        const vtxCacheSize = vtxView.getUint32(0x04, true);
        const vtxMaxBonesPerStrip = vtxView.getUint16(0x08, true);
        const vtxMaxBonesPerTri = vtxView.getUint16(0x0A, true);
        const vtxMaxBonesPerVert = vtxView.getUint32(0x0C, true);

        const vtxChecksum = vtxView.getUint32(0x10, true);
        assert(vtxChecksum === this.checksum);

        const vtxNumLODs = vtxView.getUint32(0x14, true);
        assert(vtxNumLODs === vvdNumLODs);
        const vtxMaterialReplacementListOffset = vtxView.getUint32(0x18, true);
        const vtxNumBodyParts = vtxView.getUint32(0x1C, true);
        assert(vtxNumBodyParts === numbodyparts);
        const vtxBodyPartOffset = vtxView.getUint32(0x20, true);

        // Gather our materials for each LOD.
        // First, gather our base material names.
        const baseMaterialNames: string[] = [];
        let textureIdx = textureindex;
        for (let i = 0; i < numtextures; i++) {
            const nameindex = textureIdx + mdlView.getUint32(textureIdx + 0x00, true);
            const materialName = readString(mdlBuffer, nameindex);
            const flags = mdlView.getUint32(textureIdx + 0x04, true);
            const used = mdlView.getUint32(textureIdx + 0x08, true);
            const unused1 = mdlView.getUint32(textureIdx + 0x0C, true);
            const material = mdlView.getUint32(textureIdx + 0x10, true);
            // This appears to be a stale pointer generated by studiomdl, lol.
            // assert(material === 0);
            const clientmaterial = mdlView.getUint32(textureIdx + 0x14, true);
            assert(clientmaterial === 0);

            const resolvedPath = renderContext.filesystem.searchPath(materialSearchDirs, materialName, '.vmt');
            if (resolvedPath !== null) {
                baseMaterialNames.push(resolvedPath);
            } else {
                // TODO(jstpierre): Error material
                baseMaterialNames.push('materials/editor/obsolete.vmt');
            }

            textureIdx += 0x40;
        }

        const lodMaterialNames: string[][] = [];
        let vtxMaterialReplacementListIdx = vtxMaterialReplacementListOffset;
        for (let i = 0; i < vtxNumLODs; i++) {
            const numReplacements = vtxView.getUint32(vtxMaterialReplacementListIdx + 0x00, true);
            const replacementOffset = vtxView.getInt32(vtxMaterialReplacementListIdx + 0x04, true);

            const materialNames: string[] = baseMaterialNames.slice();
            let replacementIdx = vtxMaterialReplacementListIdx + replacementOffset;
            for (let i = 0; i < numReplacements; i++) {
                const materialID = vtxView.getUint16(replacementIdx + 0x00, true);
                assert(materialID < materialNames.length);
                const nameOffset = replacementIdx + vtxView.getInt32(replacementIdx + 0x02, true);
                const replacementName = readString(vtxBuffer, nameOffset);
                materialNames[materialID] = assertExists(renderContext.filesystem.searchPath(materialSearchDirs, replacementName, '.vmt'));
                replacementIdx += 0x06;
            }

            lodMaterialNames.push(materialNames);
            vtxMaterialReplacementListIdx += 0x08;
        }

        // The hierarchy of a model is Body Part -> Submodel -> Submodel LOD -> Mesh -> Strip Group -> Strip
        // Note that "strips" might not actually be tristrips. They appear to be trilists in modern models.

        let mdlBodyPartIdx = bodypartindex;
        let vtxBodyPartIdx = vtxBodyPartOffset;
        for (let i = 0; i < numbodyparts; i++) {
            const bodyPartName = readString(mdlBuffer, mdlBodyPartIdx + mdlView.getUint32(mdlBodyPartIdx + 0x00, true));
            const mdlNumModels = mdlView.getUint32(mdlBodyPartIdx + 0x04, true);
            const mdlBase = mdlView.getUint32(mdlBodyPartIdx + 0x08, true);
            const mdlModelindex = mdlView.getUint32(mdlBodyPartIdx + 0x0C, true);

            const vtxNumModels = vtxView.getUint32(vtxBodyPartIdx + 0x00, true);
            assert(mdlNumModels === vtxNumModels);
            const vtxModelOffs = vtxView.getUint32(vtxBodyPartIdx + 0x04, true);

            const bodyPartData = new StudioModelBodyPartData(bodyPartName);
            this.bodyPartData.push(bodyPartData);

            let mdlSubmodelIdx = mdlBodyPartIdx + mdlModelindex;
            let vtxSubmodelIdx = vtxBodyPartIdx + vtxModelOffs;
            for (let j = 0; j < mdlNumModels; j++) {
                const mdlSubmodelName = readString(mdlBuffer, mdlSubmodelIdx + 0x00);
                // Never written to.
                // const mdlSubmodelType = mdlView.getUint32(mdlSubmodelIdx + 0x40, true);
                const mdlSubmodelBoundingRadius = mdlView.getFloat32(mdlSubmodelIdx + 0x44, true);
                const mdlSubmodelNumMeshes = mdlView.getUint32(mdlSubmodelIdx + 0x48, true);
                const mdlSubmodelMeshindex = mdlView.getUint32(mdlSubmodelIdx + 0x4C, true);
                const mdlSubmodelNumvertices = mdlView.getUint32(mdlSubmodelIdx + 0x50, true);
                const mdlSubmodelVertexindex = mdlView.getUint32(mdlSubmodelIdx + 0x54, true);
                const mdlSubmodelTangentsindex = mdlView.getUint32(mdlSubmodelIdx + 0x58, true);
                const mdlSubmodelNumattachments = mdlView.getUint32(mdlSubmodelIdx + 0x5C, true);
                const mdlSubmodelAttachmentindex = mdlView.getUint32(mdlSubmodelIdx + 0x60, true);
                const mdlSubmodelNumeyeballs = mdlView.getUint32(mdlSubmodelIdx + 0x64, true);
                const mdlSubmodelEyeballindex = mdlView.getUint32(mdlSubmodelIdx + 0x68, true);

                // mstudio_modelvertexdata_t
                // const mdlSubmodelVertexDataPtr = mdlView.getUint32(mdlSubmodelIdx + 0x6C, true); junk pointer
                // const mdlSubmodelTangentsDataPtr = mdlView.getUint32(mdlSubmodelIdx + 0x70, true); junk pointer
                const vvdSubmodelVertexDataOffs = vvdVertexDataStart + mdlSubmodelVertexindex;
                const vvdSubmodelTangentDataOffs = vvdTangentDataStart + mdlSubmodelTangentsindex;

                // int unused[8];

                const vtxSubmodelNumLODs = vtxView.getUint32(vtxSubmodelIdx + 0x00, true);
                assert(vtxSubmodelNumLODs === vtxNumLODs);
                const vtxSubmodelLODOffset = vtxView.getUint32(vtxSubmodelIdx + 0x04, true);

                const submodelData = new StudioModelSubmodelData(mdlSubmodelName);
                bodyPartData.submodelData.push(submodelData);

                let vtxLODIdx = vtxSubmodelIdx + vtxSubmodelLODOffset;
                for (let lod = 0; lod < vtxSubmodelNumLODs; lod++) {
                    const vtxNumMeshes = vtxView.getUint32(vtxLODIdx + 0x00, true);
                    assert(vtxNumMeshes === mdlSubmodelNumMeshes);
                    const vtxMeshOffset = vtxView.getUint32(vtxLODIdx + 0x04, true);
                    const vtxSwitchPoint = vtxView.getFloat32(vtxLODIdx + 0x08, true);

                    const lodData = new StudioModelLODData();
                    submodelData.lodData.push(lodData);
                    let mdlMeshIdx = mdlSubmodelIdx + mdlSubmodelMeshindex;
                    let vtxMeshIdx = vtxLODIdx + vtxMeshOffset;
                    for (let m = 0; m < mdlSubmodelNumMeshes; m++) {
                        // MDL data is not LOD-specific, we reparse this for each LOD.
                        const material = mdlView.getUint32(mdlMeshIdx + 0x00, true);
                        const modelindex = mdlView.getInt32(mdlMeshIdx + 0x04, true);
                        const materialName = lodMaterialNames[lod][material];

                        const mdlMeshNumvertices = mdlView.getUint32(mdlMeshIdx + 0x08, true);
                        const mdlMeshVertexoffset = mdlView.getUint32(mdlMeshIdx + 0x0C, true);

                        const numflexes = mdlView.getUint32(mdlMeshIdx + 0x10, true);
                        const flexindex = mdlView.getUint32(mdlMeshIdx + 0x14, true);

                        const materialtype = mdlView.getUint32(mdlMeshIdx + 0x18, true);
                        // assert(materialtype === 0); // not eyeballs
                        const materialparam = mdlView.getUint32(mdlMeshIdx + 0x1C, true);

                        const meshid = mdlView.getUint32(mdlMeshIdx + 0x20, true);
                        const centerX = mdlView.getFloat32(mdlMeshIdx + 0x24, true);
                        const centerY = mdlView.getFloat32(mdlMeshIdx + 0x28, true);
                        const centerZ = mdlView.getFloat32(mdlMeshIdx + 0x2C, true);

                        // mstudio_meshvertexdata_t
                        // const modelvertexdata = mdlView.getUint32(mdlMeshIdx + 0x30, true); junk pointer
                        const lodVertices = mdlView.getUint32(mdlMeshIdx + 0x34 + lod * 0x04, true);

                        // On the VTX side, each mesh contains a number of "strip groups". In theory, there can be up to
                        // four different strip groups for the 2x2 combinatoric matrix of "hw skin" and "is flex".
                        // We load the DX90 VTX files, which always have hw skin enabled, so we should see at most two
                        // flex groups.
                        const vtxNumStripGroups = vtxView.getUint32(vtxMeshIdx + 0x00, true);

                        // TODO(jstpierre): It seems some non-hw-skin groups are showing up in DX90 files in HL2?
                        // assert(vtxNumStripGroups === 1 || vtxNumStripGroups === 2);

                        const vtxStripGroupHeaderOffset = vtxView.getUint32(vtxMeshIdx + 0x04, true);
                        const vtxMeshFlags = vtxView.getUint8(vtxMeshIdx + 0x08);

                        let meshNumVertices = 0;
                        let meshNumIndices = 0;
                        let vtxStripGroupIdx = vtxMeshIdx + vtxStripGroupHeaderOffset;
                        for (let g = 0; g < vtxNumStripGroups; g++, vtxStripGroupIdx += 0x19) {
                            const numVerts = vtxView.getUint32(vtxStripGroupIdx + 0x00, true);
                            const numIndices = vtxView.getUint32(vtxStripGroupIdx + 0x08, true);
                            meshNumVertices += numVerts;
                            meshNumIndices += numIndices;
                        }

                        // 3 pos, 4 normal, 4 tangent, 2 uv, 4 bone weight, 4 bone id
                        const vertexSize = (3+4+4+2+4+4);
                        const meshVtxData = new Float32Array(meshNumVertices * vertexSize);
                        const meshIdxData = new Uint16Array(meshNumIndices);

                        let dataOffs = 0x00;
                        let meshIdxBase = 0;
                        let idxOffs = 0x00;
                        let meshFirstIdx = 0;

                        const stripGroupDatas: StudioModelStripGroupData[] = [];

                        vtxStripGroupIdx = vtxMeshIdx + vtxStripGroupHeaderOffset;
                        for (let g = 0; g < vtxNumStripGroups; g++, vtxStripGroupIdx += 0x19) {
                            const numVerts = vtxView.getUint32(vtxStripGroupIdx + 0x00, true);
                            const vertOffset = vtxView.getUint32(vtxStripGroupIdx + 0x04, true);

                            const numIndices = vtxView.getUint32(vtxStripGroupIdx + 0x08, true);
                            const indexOffset = vtxView.getUint32(vtxStripGroupIdx + 0x0C, true);

                            const numStrips = vtxView.getUint32(vtxStripGroupIdx + 0x10, true);
                            const stripOffset = vtxView.getUint32(vtxStripGroupIdx + 0x14, true);

                            const stripGroupFlags: OptimizeStripGroupFlags = vtxView.getUint8(vtxStripGroupIdx + 0x18);

                            // DX90 VTX models should always have hw skin enabled.
                            // TODO(jstpierre): Figure out why this is breaking on HL2's "female_07" model. Eyeballs?
                            if (!(stripGroupFlags & OptimizeStripGroupFlags.IS_HWSKINNED))
                                continue;

                            // Build the vertex data for our strip group.
                            let vertIdx = vtxStripGroupIdx + vertOffset;
                            for (let v = 0; v < numVerts; v++) {
                                // VTX Bone weight data.
                                const vtxBoneWeightIdx = [
                                    vtxView.getUint8(vertIdx + 0x00),
                                    vtxView.getUint8(vertIdx + 0x01),
                                    vtxView.getUint8(vertIdx + 0x02),
                                ];
                                const vtxNumBones = vtxView.getUint8(vertIdx + 0x03);

                                const vtxOrigMeshVertID = vtxView.getUint16(vertIdx + 0x04, true);
                                const vtxBoneID = [
                                    vtxView.getUint8(vertIdx + 0x06),
                                    vtxView.getUint8(vertIdx + 0x07),
                                    vtxView.getUint8(vertIdx + 0x08),
                                ];

                                // Pull out VVD vertex data.
                                const modelVertIndex = (mdlMeshVertexoffset + vtxOrigMeshVertID);
                                const vvdVertIndex = fixupRemappingSearch(fixupRemappings, modelVertIndex);
                                const vvdVertexOffs = vvdSubmodelVertexDataOffs + 0x30 * vvdVertIndex;
                                const vvdTangentOffs = vvdSubmodelTangentDataOffs + 0x10 * vvdVertIndex;

                                const vvdBoneWeight = [
                                    vvdView.getFloat32(vvdVertexOffs + 0x00, true),
                                    vvdView.getFloat32(vvdVertexOffs + 0x04, true),
                                    vvdView.getFloat32(vvdVertexOffs + 0x08, true),
                                ];
                                const vvdBoneIdx = [
                                    vvdView.getUint8(vvdVertexOffs + 0x0C),
                                    vvdView.getUint8(vvdVertexOffs + 0x0D),
                                    vvdView.getUint8(vvdVertexOffs + 0x0E),
                                ];
                                const vvdNumBones = vvdView.getUint8(vvdVertexOffs + 0x0F);

                                const boneWeights: number[] = [0, 0, 0, 0];

                                let totalBoneWeight = 0.0;
                                for (let i = 0; i < vtxNumBones; i++) {
                                    const boneWeightIdx = vtxBoneWeightIdx[i];
                                    boneWeights[i] = vvdBoneWeight[boneWeightIdx];
                                    totalBoneWeight += boneWeights[i];
                                }

                                // Normalize.
                                for (let i = 0; i < vtxNumBones; i++)
                                    boneWeights[i] /= totalBoneWeight;

                                const vvdPositionX = vvdView.getFloat32(vvdVertexOffs + 0x10, true);
                                const vvdPositionY = vvdView.getFloat32(vvdVertexOffs + 0x14, true);
                                const vvdPositionZ = vvdView.getFloat32(vvdVertexOffs + 0x18, true);

                                const vvdNormalX = vvdView.getFloat32(vvdVertexOffs + 0x1C, true);
                                const vvdNormalY = vvdView.getFloat32(vvdVertexOffs + 0x20, true);
                                const vvdNormalZ = vvdView.getFloat32(vvdVertexOffs + 0x24, true);

                                const vvdTexCoordS = vvdView.getFloat32(vvdVertexOffs + 0x28, true);
                                const vvdTexCoordT = vvdView.getFloat32(vvdVertexOffs + 0x2C, true);

                                const vvdTangentSX = vvdView.getFloat32(vvdTangentOffs + 0x00, true);
                                const vvdTangentSY = vvdView.getFloat32(vvdTangentOffs + 0x04, true);
                                const vvdTangentSZ = vvdView.getFloat32(vvdTangentOffs + 0x08, true);
                                const vvdTangentSW = vvdView.getFloat32(vvdTangentOffs + 0x0C, true);

                                // Sanity check our tangent sign data.
                                // TODO(jstpierre): Check the tangent data validity against our material.
                                assert(vvdTangentSW === 0.0 || vvdTangentSW === 1.0 || vvdTangentSW === -1.0);

                                // Position
                                meshVtxData[dataOffs++] = vvdPositionX;
                                meshVtxData[dataOffs++] = vvdPositionY;
                                meshVtxData[dataOffs++] = vvdPositionZ;

                                // Normal
                                meshVtxData[dataOffs++] = vvdNormalX;
                                meshVtxData[dataOffs++] = vvdNormalY;
                                meshVtxData[dataOffs++] = vvdNormalZ;
                                meshVtxData[dataOffs++] = 1.0; // vertex alpha

                                // Tangent
                                meshVtxData[dataOffs++] = vvdTangentSX;
                                meshVtxData[dataOffs++] = vvdTangentSY;
                                meshVtxData[dataOffs++] = vvdTangentSZ;
                                meshVtxData[dataOffs++] = vvdTangentSW;

                                // Texcoord
                                meshVtxData[dataOffs++] = vvdTexCoordS;
                                meshVtxData[dataOffs++] = vvdTexCoordT;

                                // Bone weights
                                meshVtxData[dataOffs++] = boneWeights[0];
                                meshVtxData[dataOffs++] = boneWeights[1];
                                meshVtxData[dataOffs++] = boneWeights[2];
                                meshVtxData[dataOffs++] = boneWeights[3];

                                // Bone IDs
                                meshVtxData[dataOffs++] = vtxBoneID[0];
                                meshVtxData[dataOffs++] = vtxBoneID[1];
                                meshVtxData[dataOffs++] = vtxBoneID[2];
                                meshVtxData[dataOffs++] = 0;

                                vertIdx += 0x09;
                            }

                            let indexIdx = vtxStripGroupIdx + indexOffset;
                            for (let i = 0; i < numIndices; i++) {
                                meshIdxData[idxOffs++] = meshIdxBase + vtxView.getUint16(indexIdx, true);
                                indexIdx += 0x02;
                            }

                            meshIdxBase += numVerts;

                            const stripGroupData = new StudioModelStripGroupData();
                            stripGroupDatas.push(stripGroupData);

                            // Note that as noted before, "tristrip" in modern models refers mostly to trilists, not tristrips.
                            // We can have multiple strips in a strip group if we have a bone change table between strips.
                            // For unskinned / static prop models without bones, we should always have one strip.

                            // Each strip in a strip group can change the bones, relative to the previous one.
                            const hardwareBoneTable: number[] = [];

                            let vtxStripIdx = vtxStripGroupIdx + stripOffset;
                            // assert(numStrips === 1);
                            for (let s = 0; s < numStrips; s++) {
                                const stripNumIndices = vtxView.getUint32(vtxStripIdx + 0x00, true);
                                const stripIndexOffset = vtxView.getUint32(vtxStripIdx + 0x04, true);
                                // assert(stripNumIndices === numIndices);
                                // assert(stripIndexOffset === 0);

                                const stripNumVerts = vtxView.getUint32(vtxStripIdx + 0x08, true);
                                const stripVertOffset = vtxView.getUint32(vtxStripIdx + 0x0C, true);
                                // assert(stripNumVerts === numVerts);
                                // assert(stripVertOffset === 0);

                                const numBones = vtxView.getUint16(vtxStripIdx + 0x10, true);

                                const stripFlags: OptimizeStripFlags = vtxView.getUint8(vtxStripIdx + 0x12);
                                assert(stripFlags === OptimizeStripFlags.IS_TRILIST);

                                const numBoneStateChanges = vtxView.getUint32(vtxStripIdx + 0x13, true);
                                const boneStateChangeOffset = vtxView.getUint32(vtxStripIdx + 0x17, true);
                                let boneStateChangeIdx = boneStateChangeOffset;

                                for (let i = 0; i < numBoneStateChanges; i++) {
                                    const hardwareID = vtxView.getUint32(vtxStripIdx + boneStateChangeIdx + 0x00, true);
                                    const boneID = vtxView.getUint32(vtxStripIdx + boneStateChangeIdx + 0x04, true);
                                    hardwareBoneTable[hardwareID] = boneID;
                                    boneStateChangeIdx += 0x08;
                                }

                                stripGroupData.stripData.push(new StudioModelStripData(meshFirstIdx + stripIndexOffset, stripNumIndices, hardwareBoneTable.slice()));

                                vtxStripIdx += 0x1B;
                            }

                            meshFirstIdx += numIndices;
                        }

                        const device = renderContext.device, cache = renderContext.cache;
                        const meshData = new StudioModelMeshData(device, cache, materialName, meshVtxData.buffer, meshIdxData.buffer);
                        for (let i = 0; i < stripGroupDatas.length; i++)
                            meshData.stripGroupData.push(stripGroupDatas[i]);
                        lodData.meshData.push(meshData);

                        mdlMeshIdx += 0x74;
                        vtxMeshIdx += 0x09;
                    }

                    vtxLODIdx += 0x0C;

                    // TODO(jstpierre): Support multiple model LODs. For now, we only support the first LOD.
                    break;
                }

                mdlSubmodelIdx += 0x94;
                vtxSubmodelIdx += 0x08;

                // TODO(jstpierre): Reading models with multiple submodels seems to break right now... not sure why.
                break;
            }

            mdlBodyPartIdx += 0x10;
            vtxBodyPartIdx += 0x08;

            // TODO(jstpierre): Reading models with multiple body parts seems to break right now... not sure why.
            break;
        }
    }

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.bodyPartData.length; i++)
            this.bodyPartData[i].destroy(device);
    }
}

// Hardware verts, used for static color data

interface HardwareVertDataMesh {
    lod: number;
    indexInsideLOD: number;
    vertexCount: number;
    byteOffset: number;
    byteSize: number;
}

export class HardwareVertData {
    public checksum: number;
    public buffer: GfxBuffer;
    public mesh: HardwareVertDataMesh[] = [];

    constructor(renderContext: SourceRenderContext, buffer: ArrayBufferSlice) {
        const view = buffer.createDataView();

        const version = view.getUint32(0x00, true);
        assert(version === 0x02);

        this.checksum = view.getUint32(0x04, true);

        // Hardware verts are used solely for vertex colors

        const enum VertexFlags { POSITION = 0x01, NORMAL = 0x02, COLOR = 0x04, SPECULAR = 0x08, TANGENT_S = 0x10, TANGENT_T = 0x20, }
        const vertexFlags: VertexFlags = view.getUint32(0x08, true);
        assert(vertexFlags === VertexFlags.COLOR);

        const vertexSize: number = view.getUint32(0x0C, true);
        assert(vertexSize === 4);

        const vertexCount = view.getUint32(0x10, true);

        const numMeshes = view.getUint32(0x14, true);

        // 0x10 bytes of padding.
        const vertexData = new Uint8Array(vertexCount * 4);
        let vertexOffs = 0;

        let lastLOD = -1;
        let indexInsideLOD = 0;

        let meshHeaderIdx = 0x28;
        for (let i = 0; i < numMeshes; i++) {
            const lod = view.getUint32(meshHeaderIdx + 0x00, true);
            if (lastLOD !== lod) {
                indexInsideLOD = 0;
                lastLOD = lod;
            }

            const meshVertexCount = view.getUint32(meshHeaderIdx + 0x04, true);
            const offset = view.getUint32(meshHeaderIdx + 0x08, true);

            const meshByteSize = meshVertexCount * 4;

            this.mesh.push({ lod, indexInsideLOD, vertexCount: meshVertexCount, byteOffset: vertexOffs, byteSize: meshByteSize });

            // Input and output data are both RGBA
            // Input is BGRA, we need RGBA
            let dataOffs = offset;
            for (let i = 0; i < meshVertexCount; i++) {
                const b = view.getUint8(dataOffs++);
                const g = view.getUint8(dataOffs++);
                const r = view.getUint8(dataOffs++);
                const a = view.getUint8(dataOffs++);
                vertexData[vertexOffs++] = r;
                vertexData[vertexOffs++] = g;
                vertexData[vertexOffs++] = b;
                vertexData[vertexOffs++] = a;
            }

            // 0x10 bytes of padding.
            meshHeaderIdx += 0x1C;
        }

        this.buffer = makeStaticDataBuffer(renderContext.device, GfxBufferUsage.VERTEX, vertexData.buffer);
    }

    public destroy(device: GfxDevice): void {
        device.destroyBuffer(this.buffer);
    }
}

export class StudioModelCache {
    private modelData: StudioModelData[] = [];
    private modelDataPromiseCache = new Map<string, Promise<StudioModelData>>();

    constructor(private renderContext: SourceRenderContext, private filesystem: SourceFileSystem) {
    }

    private resolvePath(path: string, ext: string): string {
        if (path.endsWith('.mdl'))
            path = path.slice(0, -4);
        if (!path.endsWith(ext))
            path = `${path}${ext}`;
        return this.filesystem.resolvePath(path, ext);
    }

    private async fetchStudioModelDataInternal(name: string): Promise<StudioModelData> {
        const mdlPath = this.resolvePath(name, '.mdl');
        const vvdPath = this.resolvePath(name, '.vvd');
        const vtxPath = this.resolvePath(name, '.dx90.vtx');
        const [mdlBuffer, vvdBuffer, vtxBuffer] = await Promise.all([
            this.filesystem.fetchFileData(mdlPath),
            this.filesystem.fetchFileData(vvdPath),
            this.filesystem.fetchFileData(vtxPath),
        ]);
        const modelData = new StudioModelData(this.renderContext, mdlBuffer!, vvdBuffer!, vtxBuffer!);
        this.modelData.push(modelData);
        return modelData;
    }

    public fetchStudioModelData(path: string): Promise<StudioModelData> {
        if (!this.modelDataPromiseCache.has(path))
            this.modelDataPromiseCache.set(path, this.fetchStudioModelDataInternal(path));
        return this.modelDataPromiseCache.get(path)!;
    }

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.modelData.length; i++)
            this.modelData[i].destroy(device);
    }
}

class StudioModelMeshInstance {
    private visible = true;
    private materialInstance: BaseMaterial | null = null;
    private inputStateWithColorMesh: GfxInputState | null = null;
    private skinningMode: SkinningMode;

    constructor(renderContext: SourceRenderContext, private meshData: StudioModelMeshData, entityParams: EntityMaterialParameters) {
        this.bindMaterial(renderContext, entityParams);
        this.skinningMode = this.calcSkinningMode();
    }

    private syncMaterialInstanceStaticLightingMode(): void {
        if (this.materialInstance !== null) {
            const staticLightingMode = (this.inputStateWithColorMesh !== null) ? StaticLightingMode.StudioVertexLighting : StaticLightingMode.StudioAmbientCube;
            this.materialInstance.setStaticLightingMode(staticLightingMode);
        }
    }

    private calcSkinningMode(): SkinningMode {
        let maxNumBones = 0;

        for (let i = 0; i < this.meshData.stripGroupData.length; i++) {
            const stripGroupData = this.meshData.stripGroupData[i];
            for (let j = 0; j < stripGroupData.stripData.length; j++) {
                const stripData = stripGroupData.stripData[j];
                maxNumBones = Math.max(stripData.hardwareBoneTable.length, maxNumBones);
                if (maxNumBones > 1)
                    return SkinningMode.Smooth;
            }
        }

        if (maxNumBones === 1)
            return SkinningMode.Rigid;

        return SkinningMode.None;
    }

    private async bindMaterial(renderContext: SourceRenderContext, entityParams: EntityMaterialParameters): Promise<void> {
        this.materialInstance = await renderContext.materialCache.createMaterialInstance(renderContext, this.meshData.materialName, entityParams);
        this.materialInstance.setSkinningMode(this.skinningMode);
        this.syncMaterialInstanceStaticLightingMode();
    }

    public bindColorMeshData(device: GfxDevice, data: HardwareVertData, mesh: HardwareVertDataMesh): void {
        assert(this.inputStateWithColorMesh === null);

        const colorDescriptor: GfxVertexBufferDescriptor = { buffer: data.buffer, byteOffset: mesh.byteOffset };
        this.inputStateWithColorMesh = this.meshData.createInputStateWithColorMesh(device, colorDescriptor);

        this.syncMaterialInstanceStaticLightingMode();
    }

    public movement(renderContext: SourceRenderContext): void {
        if (!this.visible || this.materialInstance === null)
            return;

        this.materialInstance.movement(renderContext);
    }

    public prepareToRender(renderContext: SourceRenderContext, renderInstManager: GfxRenderInstManager, modelMatrix: ReadonlyMat4, boneMatrix: ReadonlyMat4[]) {
        if (!this.visible || this.materialInstance === null || !this.materialInstance.visible || !this.materialInstance.isMaterialLoaded())
            return;

        const template = renderInstManager.pushTemplateRenderInst();
        this.materialInstance.setOnRenderInst(renderContext, template, modelMatrix);

        // Bind color mesh if we have a per-instance version.
        if (this.inputStateWithColorMesh !== null)
            template.setInputLayoutAndState(this.meshData.inputLayoutWithColorMesh, this.inputStateWithColorMesh);
        else
            template.setInputLayoutAndState(this.meshData.inputLayoutWithoutColorMesh, this.meshData.inputStateWithoutColorMesh);

        for (let i = 0; i < this.meshData.stripGroupData.length; i++) {
            const stripGroupData = this.meshData.stripGroupData[i];

            for (let j = 0; j < stripGroupData.stripData.length; j++) {
                const stripData = stripGroupData.stripData[j];
                const renderInst = renderInstManager.newRenderInst();
                this.materialInstance.setOnRenderInstSkinningParams(renderInst, boneMatrix, stripData.hardwareBoneTable);
                renderInst.drawIndexes(stripData.indexCount, stripData.firstIndex);
                renderInstManager.submitRenderInst(renderInst);
            }
        }

        renderInstManager.popTemplateRenderInst();
    }

    public destroy(device: GfxDevice): void {
        if (this.inputStateWithColorMesh !== null)
            device.destroyInputState(this.inputStateWithColorMesh);
    }
}

class StudioModelLODInstance {
    public meshInstance: StudioModelMeshInstance[] = [];

    constructor(renderContext: SourceRenderContext, private lodData: StudioModelLODData, entityParams: EntityMaterialParameters) {
        for (let i = 0; i < this.lodData.meshData.length; i++)
            this.meshInstance.push(new StudioModelMeshInstance(renderContext, this.lodData.meshData[i], entityParams));
    }

    public movement(renderContext: SourceRenderContext): void {
        for (let i = 0; i < this.meshInstance.length; i++)
            this.meshInstance[i].movement(renderContext);
    }

    public prepareToRender(renderContext: SourceRenderContext, renderInstManager: GfxRenderInstManager, modelMatrix: ReadonlyMat4, boneMatrix: ReadonlyMat4[]) {
        for (let i = 0; i < this.meshInstance.length; i++)
            this.meshInstance[i].prepareToRender(renderContext, renderInstManager, modelMatrix, boneMatrix);
    }

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.meshInstance.length; i++)
            this.meshInstance[i].destroy(device);
    }
}

export class StudioModelInstance {
    public visible: boolean = true;
    public modelMatrix = mat4.create();
    public worldFromPoseMatrix: mat4[];

    private lodInstance: StudioModelLODInstance[] = [];

    constructor(renderContext: SourceRenderContext, public modelData: StudioModelData, materialParams: EntityMaterialParameters) {
        // assert(this.modelData.bodyPartData.length === 1);
        const bodyPartData = this.modelData.bodyPartData[0];

        // assert(bodyPartData.submodelData.length === 1);
        const submodelData = bodyPartData.submodelData[0];

        for (let k = 0; k < submodelData.lodData.length; k++) {
            const lodData = submodelData.lodData[k];
            this.lodInstance.push(new StudioModelLODInstance(renderContext, lodData, materialParams));
        }

        this.worldFromPoseMatrix = nArray(this.modelData.bones.length, () => mat4.create());
    }

    public setColorMeshData(device: GfxDevice, data: HardwareVertData): void {
        // In some TF2 games, checksums don't match. For now, apply the static lighting anyway,
        // as it won't look as bad as unlit models. If/when we do proper lighting for light probes,
        // then this can go away.

        // if (data.checksum !== this.modelData.checksum)
        //     return;

        for (let i = 0; i < this.lodInstance.length; i++) {
            const lodInstance = this.lodInstance[i];
            for (let j = 0; j < lodInstance.meshInstance.length; j++) {
                const meshInstance = lodInstance.meshInstance[j];

                // Find proper color mesh.
                const colorMesh = data.mesh.find((mesh) => mesh.lod === i && mesh.indexInsideLOD === j);
                if (colorMesh === undefined)
                    continue;

                meshInstance.bindColorMeshData(device, data, colorMesh);
            }
        }
    }

    private getLODModelIndex(renderContext: SourceRenderContext): number {
        // TODO(jstpierre): Pull out the proper LOD model.
        return 0;
    }

    public movement(renderContext: SourceRenderContext): void {
        const lodIndex = this.getLODModelIndex(renderContext);
        this.lodInstance[lodIndex].movement(renderContext);
    }

    public prepareToRender(renderContext: SourceRenderContext, renderInstManager: GfxRenderInstManager) {
        if (!this.visible)
            return;

        for (let i = 0; i < this.worldFromPoseMatrix.length; i++) {
            const bone = this.modelData.bones[i];

            // Parent-from-bone
            computeModelMatrixPosRadianEuler(this.worldFromPoseMatrix[i], bone.pos, bone.rot);

            // World-from-bone
            const parentBoneMatrix = bone.parent >= 0 ? this.worldFromPoseMatrix[bone.parent] : this.modelMatrix;
            mat4.mul(this.worldFromPoseMatrix[i], parentBoneMatrix, this.worldFromPoseMatrix[i]);
        }

        for (let i = 0; i < this.worldFromPoseMatrix.length; i++) {
            // After we've built our world-from-bone array, compute world-from-pose.
            mat4.mul(this.worldFromPoseMatrix[i], this.worldFromPoseMatrix[i], this.modelData.bones[i].poseToBone);
        }

        const lodIndex = this.getLODModelIndex(renderContext);
        this.lodInstance[lodIndex].prepareToRender(renderContext, renderInstManager, this.modelMatrix, this.worldFromPoseMatrix);
    }

    public destroy(device: GfxDevice): void {
        for (let i = 0; i < this.lodInstance.length; i++)
            this.lodInstance[i].destroy(device);
    }
}
